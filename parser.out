Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> class
Rule 1     class -> CLASS name LCURLY classVarDecs subroutineDecs RCURLY
Rule 2     classVarDecs -> STATIC type name commaClassVarNames SEMICOLON classVarDecs
Rule 3     classVarDecs -> FIELD type name commaClassVarNames SEMICOLON classVarDecs
Rule 4     classVarDecs -> empty
Rule 5     commaClassVarNames -> COMMA name commaClassVarNames
Rule 6     commaClassVarNames -> empty
Rule 7     type -> INT
Rule 8     type -> CHAR
Rule 9     type -> BOOLEAN
Rule 10    type -> name
Rule 11    subroutineDecs -> CONSTRUCTOR VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 12    subroutineDecs -> CONSTRUCTOR type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 13    subroutineDecs -> FUNCTION VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 14    subroutineDecs -> FUNCTION type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 15    subroutineDecs -> METHOD VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 16    subroutineDecs -> METHOD type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 17    subroutineDecs -> empty
Rule 18    parameterList -> type name additionalParameters
Rule 19    parameterList -> empty
Rule 20    additionalParameters -> COMMA type name additionalParameters
Rule 21    additionalParameters -> empty
Rule 22    subroutineBody -> LCURLY varDecs statements RCURLY
Rule 23    varDecs -> VAR type name commaVarNames SEMICOLON varDecs
Rule 24    varDecs -> empty
Rule 25    commaVarNames -> COMMA name commaVarNames
Rule 26    commaVarNames -> empty
Rule 27    name -> IDENTIFIER
Rule 28    statements -> statement statements
Rule 29    statements -> empty
Rule 30    statement -> letStatement
Rule 31    statement -> ifStatement
Rule 32    statement -> whileStatement
Rule 33    statement -> doStatement
Rule 34    statement -> returnStatement
Rule 35    letStatement -> LET name EQ expression SEMICOLON
Rule 36    letStatement -> LET name LSQUARE expression RSQUARE EQ expression SEMICOLON
Rule 37    ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY
Rule 38    ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
Rule 39    whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY
Rule 40    doStatement -> DO subroutineCall SEMICOLON
Rule 41    returnStatement -> RETURN SEMICOLON
Rule 42    returnStatement -> RETURN expression SEMICOLON
Rule 43    expression -> term opTerms
Rule 44    opTerms -> op term opTerms
Rule 45    opTerms -> empty
Rule 46    term -> INT_CONST
Rule 47    term -> LPAREN expression RPAREN
Rule 48    term -> unaryOp term
Rule 49    term -> subroutineCall
Rule 50    term -> name
Rule 51    term -> keywordConstant
Rule 52    term -> STRING_CONST
Rule 53    term -> name LSQUARE expression RSQUARE
Rule 54    subroutineCall -> name LPAREN expressionList RPAREN
Rule 55    subroutineCall -> name DOT name LPAREN expressionList RPAREN
Rule 56    expressionList -> expression commaExpressions
Rule 57    expressionList -> empty
Rule 58    commaExpressions -> COMMA expression commaExpressions
Rule 59    commaExpressions -> empty
Rule 60    op -> PLUS
Rule 61    op -> MINUS
Rule 62    op -> TIMES
Rule 63    op -> DIVIDE
Rule 64    op -> AMP
Rule 65    op -> PIPE
Rule 66    op -> LT
Rule 67    op -> GT
Rule 68    op -> EQ
Rule 69    unaryOp -> MINUS
Rule 70    unaryOp -> TILDE
Rule 71    keywordConstant -> TRUE
Rule 72    keywordConstant -> FALSE
Rule 73    keywordConstant -> NULL
Rule 74    keywordConstant -> THIS
Rule 75    empty -> <empty>

Terminals, with rules where they appear

AMP                  : 64
BOOLEAN              : 9
CHAR                 : 8
CLASS                : 1
COMMA                : 5 20 25 58
CONSTRUCTOR          : 11 12
DIVIDE               : 63
DO                   : 40
DOT                  : 55
ELSE                 : 38
EQ                   : 35 36 68
FALSE                : 72
FIELD                : 3
FUNCTION             : 13 14
GT                   : 67
IDENTIFIER           : 27
IF                   : 37 38
INT                  : 7
INT_CONST            : 46
LCURLY               : 1 22 37 38 38 39
LET                  : 35 36
LPAREN               : 11 12 13 14 15 16 37 38 39 47 54 55
LSQUARE              : 36 53
LT                   : 66
METHOD               : 15 16
MINUS                : 61 69
NULL                 : 73
PIPE                 : 65
PLUS                 : 60
RCURLY               : 1 22 37 38 38 39
RETURN               : 41 42
RPAREN               : 11 12 13 14 15 16 37 38 39 47 54 55
RSQUARE              : 36 53
SEMICOLON            : 2 3 23 35 36 40 41 42
STATIC               : 2
STRING_CONST         : 52
THIS                 : 74
TILDE                : 70
TIMES                : 62
TRUE                 : 71
VAR                  : 23
VOID                 : 11 13 15
WHILE                : 39
error                : 

Nonterminals, with rules where they appear

additionalParameters : 18 20
class                : 0
classVarDecs         : 1 2 3
commaClassVarNames   : 2 3 5
commaExpressions     : 56 58
commaVarNames        : 23 25
doStatement          : 33
empty                : 4 6 17 19 21 24 26 29 45 57 59
expression           : 35 36 36 37 38 39 42 47 53 56 58
expressionList       : 54 55
ifStatement          : 31
keywordConstant      : 51
letStatement         : 30
name                 : 1 2 3 5 10 11 12 13 14 15 16 18 20 23 25 35 36 50 53 54 55 55
op                   : 44
opTerms              : 43 44
parameterList        : 11 12 13 14 15 16
returnStatement      : 34
statement            : 28
statements           : 22 28 37 38 38 39
subroutineBody       : 11 12 13 14 15 16
subroutineCall       : 40 49
subroutineDecs       : 1 11 12 13 14 15 16
term                 : 43 44 48
type                 : 2 3 12 14 16 18 20 23
unaryOp              : 48
varDecs              : 22 23
whileStatement       : 32

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . CLASS name LCURLY classVarDecs subroutineDecs RCURLY

    CLASS           shift and go to state 1

    class                          shift and go to state 2

state 1

    (1) class -> CLASS . name LCURLY classVarDecs subroutineDecs RCURLY
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 3

state 2

    (0) S' -> class .



state 3

    (1) class -> CLASS name . LCURLY classVarDecs subroutineDecs RCURLY

    LCURLY          shift and go to state 5


state 4

    (27) name -> IDENTIFIER .

    LSQUARE         reduce using rule 27 (name -> IDENTIFIER .)
    LPAREN          reduce using rule 27 (name -> IDENTIFIER .)
    DOT             reduce using rule 27 (name -> IDENTIFIER .)
    PLUS            reduce using rule 27 (name -> IDENTIFIER .)
    MINUS           reduce using rule 27 (name -> IDENTIFIER .)
    TIMES           reduce using rule 27 (name -> IDENTIFIER .)
    DIVIDE          reduce using rule 27 (name -> IDENTIFIER .)
    AMP             reduce using rule 27 (name -> IDENTIFIER .)
    PIPE            reduce using rule 27 (name -> IDENTIFIER .)
    LT              reduce using rule 27 (name -> IDENTIFIER .)
    GT              reduce using rule 27 (name -> IDENTIFIER .)
    EQ              reduce using rule 27 (name -> IDENTIFIER .)
    COMMA           reduce using rule 27 (name -> IDENTIFIER .)
    RPAREN          reduce using rule 27 (name -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 27 (name -> IDENTIFIER .)
    LCURLY          reduce using rule 27 (name -> IDENTIFIER .)
    SEMICOLON       reduce using rule 27 (name -> IDENTIFIER .)
    RSQUARE         reduce using rule 27 (name -> IDENTIFIER .)


state 5

    (1) class -> CLASS name LCURLY . classVarDecs subroutineDecs RCURLY
    (2) classVarDecs -> . STATIC type name commaClassVarNames SEMICOLON classVarDecs
    (3) classVarDecs -> . FIELD type name commaClassVarNames SEMICOLON classVarDecs
    (4) classVarDecs -> . empty
    (75) empty -> .

    STATIC          shift and go to state 8
    FIELD           shift and go to state 6
    CONSTRUCTOR     reduce using rule 75 (empty -> .)
    FUNCTION        reduce using rule 75 (empty -> .)
    METHOD          reduce using rule 75 (empty -> .)
    RCURLY          reduce using rule 75 (empty -> .)

    classVarDecs                   shift and go to state 7
    empty                          shift and go to state 9

state 6

    (3) classVarDecs -> FIELD . type name commaClassVarNames SEMICOLON classVarDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (27) name -> . IDENTIFIER

    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    IDENTIFIER      shift and go to state 4

    type                           shift and go to state 14
    name                           shift and go to state 11

state 7

    (1) class -> CLASS name LCURLY classVarDecs . subroutineDecs RCURLY
    (11) subroutineDecs -> . CONSTRUCTOR VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (75) empty -> .

    CONSTRUCTOR     shift and go to state 16
    FUNCTION        shift and go to state 15
    METHOD          shift and go to state 17
    RCURLY          reduce using rule 75 (empty -> .)

    subroutineDecs                 shift and go to state 18
    empty                          shift and go to state 19

state 8

    (2) classVarDecs -> STATIC . type name commaClassVarNames SEMICOLON classVarDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (27) name -> . IDENTIFIER

    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    IDENTIFIER      shift and go to state 4

    type                           shift and go to state 20
    name                           shift and go to state 11

state 9

    (4) classVarDecs -> empty .

    CONSTRUCTOR     reduce using rule 4 (classVarDecs -> empty .)
    FUNCTION        reduce using rule 4 (classVarDecs -> empty .)
    METHOD          reduce using rule 4 (classVarDecs -> empty .)
    RCURLY          reduce using rule 4 (classVarDecs -> empty .)


state 10

    (8) type -> CHAR .

    IDENTIFIER      reduce using rule 8 (type -> CHAR .)


state 11

    (10) type -> name .

    IDENTIFIER      reduce using rule 10 (type -> name .)


state 12

    (7) type -> INT .

    IDENTIFIER      reduce using rule 7 (type -> INT .)


state 13

    (9) type -> BOOLEAN .

    IDENTIFIER      reduce using rule 9 (type -> BOOLEAN .)


state 14

    (3) classVarDecs -> FIELD type . name commaClassVarNames SEMICOLON classVarDecs
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 21

state 15

    (13) subroutineDecs -> FUNCTION . VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> FUNCTION . type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (27) name -> . IDENTIFIER

    VOID            shift and go to state 22
    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    IDENTIFIER      shift and go to state 4

    type                           shift and go to state 23
    name                           shift and go to state 11

state 16

    (11) subroutineDecs -> CONSTRUCTOR . VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> CONSTRUCTOR . type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (27) name -> . IDENTIFIER

    VOID            shift and go to state 24
    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    IDENTIFIER      shift and go to state 4

    type                           shift and go to state 25
    name                           shift and go to state 11

state 17

    (15) subroutineDecs -> METHOD . VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> METHOD . type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (27) name -> . IDENTIFIER

    VOID            shift and go to state 26
    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    IDENTIFIER      shift and go to state 4

    type                           shift and go to state 27
    name                           shift and go to state 11

state 18

    (1) class -> CLASS name LCURLY classVarDecs subroutineDecs . RCURLY

    RCURLY          shift and go to state 28


state 19

    (17) subroutineDecs -> empty .

    RCURLY          reduce using rule 17 (subroutineDecs -> empty .)


state 20

    (2) classVarDecs -> STATIC type . name commaClassVarNames SEMICOLON classVarDecs
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 29

state 21

    (3) classVarDecs -> FIELD type name . commaClassVarNames SEMICOLON classVarDecs
    (5) commaClassVarNames -> . COMMA name commaClassVarNames
    (6) commaClassVarNames -> . empty
    (75) empty -> .

    COMMA           shift and go to state 31
    SEMICOLON       reduce using rule 75 (empty -> .)

    commaClassVarNames             shift and go to state 30
    empty                          shift and go to state 32

state 22

    (13) subroutineDecs -> FUNCTION VOID . name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 33

state 23

    (14) subroutineDecs -> FUNCTION type . name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 34

state 24

    (11) subroutineDecs -> CONSTRUCTOR VOID . name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 35

state 25

    (12) subroutineDecs -> CONSTRUCTOR type . name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 36

state 26

    (15) subroutineDecs -> METHOD VOID . name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 37

state 27

    (16) subroutineDecs -> METHOD type . name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 38

state 28

    (1) class -> CLASS name LCURLY classVarDecs subroutineDecs RCURLY .

    $end            reduce using rule 1 (class -> CLASS name LCURLY classVarDecs subroutineDecs RCURLY .)


state 29

    (2) classVarDecs -> STATIC type name . commaClassVarNames SEMICOLON classVarDecs
    (5) commaClassVarNames -> . COMMA name commaClassVarNames
    (6) commaClassVarNames -> . empty
    (75) empty -> .

    COMMA           shift and go to state 31
    SEMICOLON       reduce using rule 75 (empty -> .)

    commaClassVarNames             shift and go to state 39
    empty                          shift and go to state 32

state 30

    (3) classVarDecs -> FIELD type name commaClassVarNames . SEMICOLON classVarDecs

    SEMICOLON       shift and go to state 40


state 31

    (5) commaClassVarNames -> COMMA . name commaClassVarNames
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 41

state 32

    (6) commaClassVarNames -> empty .

    SEMICOLON       reduce using rule 6 (commaClassVarNames -> empty .)


state 33

    (13) subroutineDecs -> FUNCTION VOID name . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 42


state 34

    (14) subroutineDecs -> FUNCTION type name . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 43


state 35

    (11) subroutineDecs -> CONSTRUCTOR VOID name . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 44


state 36

    (12) subroutineDecs -> CONSTRUCTOR type name . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 45


state 37

    (15) subroutineDecs -> METHOD VOID name . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 46


state 38

    (16) subroutineDecs -> METHOD type name . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 47


state 39

    (2) classVarDecs -> STATIC type name commaClassVarNames . SEMICOLON classVarDecs

    SEMICOLON       shift and go to state 48


state 40

    (3) classVarDecs -> FIELD type name commaClassVarNames SEMICOLON . classVarDecs
    (2) classVarDecs -> . STATIC type name commaClassVarNames SEMICOLON classVarDecs
    (3) classVarDecs -> . FIELD type name commaClassVarNames SEMICOLON classVarDecs
    (4) classVarDecs -> . empty
    (75) empty -> .

    STATIC          shift and go to state 8
    FIELD           shift and go to state 6
    CONSTRUCTOR     reduce using rule 75 (empty -> .)
    FUNCTION        reduce using rule 75 (empty -> .)
    METHOD          reduce using rule 75 (empty -> .)
    RCURLY          reduce using rule 75 (empty -> .)

    classVarDecs                   shift and go to state 49
    empty                          shift and go to state 9

state 41

    (5) commaClassVarNames -> COMMA name . commaClassVarNames
    (5) commaClassVarNames -> . COMMA name commaClassVarNames
    (6) commaClassVarNames -> . empty
    (75) empty -> .

    COMMA           shift and go to state 31
    SEMICOLON       reduce using rule 75 (empty -> .)

    commaClassVarNames             shift and go to state 50
    empty                          shift and go to state 32

state 42

    (13) subroutineDecs -> FUNCTION VOID name LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type name additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (75) empty -> .
    (27) name -> . IDENTIFIER

    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    RPAREN          reduce using rule 75 (empty -> .)
    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 11
    parameterList                  shift and go to state 51
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 43

    (14) subroutineDecs -> FUNCTION type name LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type name additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (75) empty -> .
    (27) name -> . IDENTIFIER

    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    RPAREN          reduce using rule 75 (empty -> .)
    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 11
    parameterList                  shift and go to state 54
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 44

    (11) subroutineDecs -> CONSTRUCTOR VOID name LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type name additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (75) empty -> .
    (27) name -> . IDENTIFIER

    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    RPAREN          reduce using rule 75 (empty -> .)
    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 11
    parameterList                  shift and go to state 55
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 45

    (12) subroutineDecs -> CONSTRUCTOR type name LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type name additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (75) empty -> .
    (27) name -> . IDENTIFIER

    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    RPAREN          reduce using rule 75 (empty -> .)
    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 11
    parameterList                  shift and go to state 56
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 46

    (15) subroutineDecs -> METHOD VOID name LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type name additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (75) empty -> .
    (27) name -> . IDENTIFIER

    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    RPAREN          reduce using rule 75 (empty -> .)
    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 11
    parameterList                  shift and go to state 57
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 47

    (16) subroutineDecs -> METHOD type name LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type name additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (75) empty -> .
    (27) name -> . IDENTIFIER

    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    RPAREN          reduce using rule 75 (empty -> .)
    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 11
    parameterList                  shift and go to state 58
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 48

    (2) classVarDecs -> STATIC type name commaClassVarNames SEMICOLON . classVarDecs
    (2) classVarDecs -> . STATIC type name commaClassVarNames SEMICOLON classVarDecs
    (3) classVarDecs -> . FIELD type name commaClassVarNames SEMICOLON classVarDecs
    (4) classVarDecs -> . empty
    (75) empty -> .

    STATIC          shift and go to state 8
    FIELD           shift and go to state 6
    CONSTRUCTOR     reduce using rule 75 (empty -> .)
    FUNCTION        reduce using rule 75 (empty -> .)
    METHOD          reduce using rule 75 (empty -> .)
    RCURLY          reduce using rule 75 (empty -> .)

    classVarDecs                   shift and go to state 59
    empty                          shift and go to state 9

state 49

    (3) classVarDecs -> FIELD type name commaClassVarNames SEMICOLON classVarDecs .

    CONSTRUCTOR     reduce using rule 3 (classVarDecs -> FIELD type name commaClassVarNames SEMICOLON classVarDecs .)
    FUNCTION        reduce using rule 3 (classVarDecs -> FIELD type name commaClassVarNames SEMICOLON classVarDecs .)
    METHOD          reduce using rule 3 (classVarDecs -> FIELD type name commaClassVarNames SEMICOLON classVarDecs .)
    RCURLY          reduce using rule 3 (classVarDecs -> FIELD type name commaClassVarNames SEMICOLON classVarDecs .)


state 50

    (5) commaClassVarNames -> COMMA name commaClassVarNames .

    SEMICOLON       reduce using rule 5 (commaClassVarNames -> COMMA name commaClassVarNames .)


state 51

    (13) subroutineDecs -> FUNCTION VOID name LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 60


state 52

    (18) parameterList -> type . name additionalParameters
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 61

state 53

    (19) parameterList -> empty .

    RPAREN          reduce using rule 19 (parameterList -> empty .)


state 54

    (14) subroutineDecs -> FUNCTION type name LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 62


state 55

    (11) subroutineDecs -> CONSTRUCTOR VOID name LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 63


state 56

    (12) subroutineDecs -> CONSTRUCTOR type name LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 64


state 57

    (15) subroutineDecs -> METHOD VOID name LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 65


state 58

    (16) subroutineDecs -> METHOD type name LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 66


state 59

    (2) classVarDecs -> STATIC type name commaClassVarNames SEMICOLON classVarDecs .

    CONSTRUCTOR     reduce using rule 2 (classVarDecs -> STATIC type name commaClassVarNames SEMICOLON classVarDecs .)
    FUNCTION        reduce using rule 2 (classVarDecs -> STATIC type name commaClassVarNames SEMICOLON classVarDecs .)
    METHOD          reduce using rule 2 (classVarDecs -> STATIC type name commaClassVarNames SEMICOLON classVarDecs .)
    RCURLY          reduce using rule 2 (classVarDecs -> STATIC type name commaClassVarNames SEMICOLON classVarDecs .)


state 60

    (13) subroutineDecs -> FUNCTION VOID name LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 67

    subroutineBody                 shift and go to state 68

state 61

    (18) parameterList -> type name . additionalParameters
    (20) additionalParameters -> . COMMA type name additionalParameters
    (21) additionalParameters -> . empty
    (75) empty -> .

    COMMA           shift and go to state 69
    RPAREN          reduce using rule 75 (empty -> .)

    empty                          shift and go to state 70
    additionalParameters           shift and go to state 71

state 62

    (14) subroutineDecs -> FUNCTION type name LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 67

    subroutineBody                 shift and go to state 72

state 63

    (11) subroutineDecs -> CONSTRUCTOR VOID name LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 67

    subroutineBody                 shift and go to state 73

state 64

    (12) subroutineDecs -> CONSTRUCTOR type name LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 67

    subroutineBody                 shift and go to state 74

state 65

    (15) subroutineDecs -> METHOD VOID name LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 67

    subroutineBody                 shift and go to state 75

state 66

    (16) subroutineDecs -> METHOD type name LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 67

    subroutineBody                 shift and go to state 76

state 67

    (22) subroutineBody -> LCURLY . varDecs statements RCURLY
    (23) varDecs -> . VAR type name commaVarNames SEMICOLON varDecs
    (24) varDecs -> . empty
    (75) empty -> .

    VAR             shift and go to state 78
    LET             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    DO              reduce using rule 75 (empty -> .)
    RETURN          reduce using rule 75 (empty -> .)
    RCURLY          reduce using rule 75 (empty -> .)

    varDecs                        shift and go to state 77
    empty                          shift and go to state 79

state 68

    (13) subroutineDecs -> FUNCTION VOID name LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (75) empty -> .

    CONSTRUCTOR     shift and go to state 16
    FUNCTION        shift and go to state 15
    METHOD          shift and go to state 17
    RCURLY          reduce using rule 75 (empty -> .)

    subroutineDecs                 shift and go to state 80
    empty                          shift and go to state 19

state 69

    (20) additionalParameters -> COMMA . type name additionalParameters
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (27) name -> . IDENTIFIER

    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    IDENTIFIER      shift and go to state 4

    type                           shift and go to state 81
    name                           shift and go to state 11

state 70

    (21) additionalParameters -> empty .

    RPAREN          reduce using rule 21 (additionalParameters -> empty .)


state 71

    (18) parameterList -> type name additionalParameters .

    RPAREN          reduce using rule 18 (parameterList -> type name additionalParameters .)


state 72

    (14) subroutineDecs -> FUNCTION type name LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (75) empty -> .

    CONSTRUCTOR     shift and go to state 16
    FUNCTION        shift and go to state 15
    METHOD          shift and go to state 17
    RCURLY          reduce using rule 75 (empty -> .)

    subroutineDecs                 shift and go to state 82
    empty                          shift and go to state 19

state 73

    (11) subroutineDecs -> CONSTRUCTOR VOID name LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (75) empty -> .

    CONSTRUCTOR     shift and go to state 16
    FUNCTION        shift and go to state 15
    METHOD          shift and go to state 17
    RCURLY          reduce using rule 75 (empty -> .)

    subroutineDecs                 shift and go to state 83
    empty                          shift and go to state 19

state 74

    (12) subroutineDecs -> CONSTRUCTOR type name LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (75) empty -> .

    CONSTRUCTOR     shift and go to state 16
    FUNCTION        shift and go to state 15
    METHOD          shift and go to state 17
    RCURLY          reduce using rule 75 (empty -> .)

    subroutineDecs                 shift and go to state 84
    empty                          shift and go to state 19

state 75

    (15) subroutineDecs -> METHOD VOID name LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (75) empty -> .

    CONSTRUCTOR     shift and go to state 16
    FUNCTION        shift and go to state 15
    METHOD          shift and go to state 17
    RCURLY          reduce using rule 75 (empty -> .)

    subroutineDecs                 shift and go to state 85
    empty                          shift and go to state 19

state 76

    (16) subroutineDecs -> METHOD type name LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type name LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (75) empty -> .

    CONSTRUCTOR     shift and go to state 16
    FUNCTION        shift and go to state 15
    METHOD          shift and go to state 17
    RCURLY          reduce using rule 75 (empty -> .)

    subroutineDecs                 shift and go to state 86
    empty                          shift and go to state 19

state 77

    (22) subroutineBody -> LCURLY varDecs . statements RCURLY
    (28) statements -> . statement statements
    (29) statements -> . empty
    (30) statement -> . letStatement
    (31) statement -> . ifStatement
    (32) statement -> . whileStatement
    (33) statement -> . doStatement
    (34) statement -> . returnStatement
    (75) empty -> .
    (35) letStatement -> . LET name EQ expression SEMICOLON
    (36) letStatement -> . LET name LSQUARE expression RSQUARE EQ expression SEMICOLON
    (37) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY
    (38) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (39) whileStatement -> . WHILE LPAREN expression RPAREN LCURLY statements RCURLY
    (40) doStatement -> . DO subroutineCall SEMICOLON
    (41) returnStatement -> . RETURN SEMICOLON
    (42) returnStatement -> . RETURN expression SEMICOLON

    RCURLY          reduce using rule 75 (empty -> .)
    LET             shift and go to state 99
    IF              shift and go to state 97
    WHILE           shift and go to state 89
    DO              shift and go to state 87
    RETURN          shift and go to state 90

    statements                     shift and go to state 88
    doStatement                    shift and go to state 91
    whileStatement                 shift and go to state 95
    letStatement                   shift and go to state 98
    statement                      shift and go to state 92
    returnStatement                shift and go to state 96
    empty                          shift and go to state 94
    ifStatement                    shift and go to state 93

state 78

    (23) varDecs -> VAR . type name commaVarNames SEMICOLON varDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . name
    (27) name -> . IDENTIFIER

    INT             shift and go to state 12
    CHAR            shift and go to state 10
    BOOLEAN         shift and go to state 13
    IDENTIFIER      shift and go to state 4

    type                           shift and go to state 100
    name                           shift and go to state 11

state 79

    (24) varDecs -> empty .

    LET             reduce using rule 24 (varDecs -> empty .)
    IF              reduce using rule 24 (varDecs -> empty .)
    WHILE           reduce using rule 24 (varDecs -> empty .)
    DO              reduce using rule 24 (varDecs -> empty .)
    RETURN          reduce using rule 24 (varDecs -> empty .)
    RCURLY          reduce using rule 24 (varDecs -> empty .)


state 80

    (13) subroutineDecs -> FUNCTION VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 13 (subroutineDecs -> FUNCTION VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 81

    (20) additionalParameters -> COMMA type . name additionalParameters
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 101

state 82

    (14) subroutineDecs -> FUNCTION type name LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 14 (subroutineDecs -> FUNCTION type name LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 83

    (11) subroutineDecs -> CONSTRUCTOR VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 11 (subroutineDecs -> CONSTRUCTOR VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 84

    (12) subroutineDecs -> CONSTRUCTOR type name LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 12 (subroutineDecs -> CONSTRUCTOR type name LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 85

    (15) subroutineDecs -> METHOD VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 15 (subroutineDecs -> METHOD VOID name LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 86

    (16) subroutineDecs -> METHOD type name LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 16 (subroutineDecs -> METHOD type name LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 87

    (40) doStatement -> DO . subroutineCall SEMICOLON
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    subroutineCall                 shift and go to state 102
    name                           shift and go to state 103

state 88

    (22) subroutineBody -> LCURLY varDecs statements . RCURLY

    RCURLY          shift and go to state 104


state 89

    (39) whileStatement -> WHILE . LPAREN expression RPAREN LCURLY statements RCURLY

    LPAREN          shift and go to state 105


state 90

    (41) returnStatement -> RETURN . SEMICOLON
    (42) returnStatement -> RETURN . expression SEMICOLON
    (43) expression -> . term opTerms
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    SEMICOLON       shift and go to state 114
    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 116
    subroutineCall                 shift and go to state 113
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107
    expression                     shift and go to state 121

state 91

    (33) statement -> doStatement .

    LET             reduce using rule 33 (statement -> doStatement .)
    IF              reduce using rule 33 (statement -> doStatement .)
    WHILE           reduce using rule 33 (statement -> doStatement .)
    DO              reduce using rule 33 (statement -> doStatement .)
    RETURN          reduce using rule 33 (statement -> doStatement .)
    RCURLY          reduce using rule 33 (statement -> doStatement .)


state 92

    (28) statements -> statement . statements
    (28) statements -> . statement statements
    (29) statements -> . empty
    (30) statement -> . letStatement
    (31) statement -> . ifStatement
    (32) statement -> . whileStatement
    (33) statement -> . doStatement
    (34) statement -> . returnStatement
    (75) empty -> .
    (35) letStatement -> . LET name EQ expression SEMICOLON
    (36) letStatement -> . LET name LSQUARE expression RSQUARE EQ expression SEMICOLON
    (37) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY
    (38) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (39) whileStatement -> . WHILE LPAREN expression RPAREN LCURLY statements RCURLY
    (40) doStatement -> . DO subroutineCall SEMICOLON
    (41) returnStatement -> . RETURN SEMICOLON
    (42) returnStatement -> . RETURN expression SEMICOLON

    RCURLY          reduce using rule 75 (empty -> .)
    LET             shift and go to state 99
    IF              shift and go to state 97
    WHILE           shift and go to state 89
    DO              shift and go to state 87
    RETURN          shift and go to state 90

    statements                     shift and go to state 122
    doStatement                    shift and go to state 91
    whileStatement                 shift and go to state 95
    letStatement                   shift and go to state 98
    statement                      shift and go to state 92
    returnStatement                shift and go to state 96
    empty                          shift and go to state 94
    ifStatement                    shift and go to state 93

state 93

    (31) statement -> ifStatement .

    LET             reduce using rule 31 (statement -> ifStatement .)
    IF              reduce using rule 31 (statement -> ifStatement .)
    WHILE           reduce using rule 31 (statement -> ifStatement .)
    DO              reduce using rule 31 (statement -> ifStatement .)
    RETURN          reduce using rule 31 (statement -> ifStatement .)
    RCURLY          reduce using rule 31 (statement -> ifStatement .)


state 94

    (29) statements -> empty .

    RCURLY          reduce using rule 29 (statements -> empty .)


state 95

    (32) statement -> whileStatement .

    LET             reduce using rule 32 (statement -> whileStatement .)
    IF              reduce using rule 32 (statement -> whileStatement .)
    WHILE           reduce using rule 32 (statement -> whileStatement .)
    DO              reduce using rule 32 (statement -> whileStatement .)
    RETURN          reduce using rule 32 (statement -> whileStatement .)
    RCURLY          reduce using rule 32 (statement -> whileStatement .)


state 96

    (34) statement -> returnStatement .

    LET             reduce using rule 34 (statement -> returnStatement .)
    IF              reduce using rule 34 (statement -> returnStatement .)
    WHILE           reduce using rule 34 (statement -> returnStatement .)
    DO              reduce using rule 34 (statement -> returnStatement .)
    RETURN          reduce using rule 34 (statement -> returnStatement .)
    RCURLY          reduce using rule 34 (statement -> returnStatement .)


state 97

    (37) ifStatement -> IF . LPAREN expression RPAREN LCURLY statements RCURLY
    (38) ifStatement -> IF . LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY

    LPAREN          shift and go to state 123


state 98

    (30) statement -> letStatement .

    LET             reduce using rule 30 (statement -> letStatement .)
    IF              reduce using rule 30 (statement -> letStatement .)
    WHILE           reduce using rule 30 (statement -> letStatement .)
    DO              reduce using rule 30 (statement -> letStatement .)
    RETURN          reduce using rule 30 (statement -> letStatement .)
    RCURLY          reduce using rule 30 (statement -> letStatement .)


state 99

    (35) letStatement -> LET . name EQ expression SEMICOLON
    (36) letStatement -> LET . name LSQUARE expression RSQUARE EQ expression SEMICOLON
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 124

state 100

    (23) varDecs -> VAR type . name commaVarNames SEMICOLON varDecs
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 125

state 101

    (20) additionalParameters -> COMMA type name . additionalParameters
    (20) additionalParameters -> . COMMA type name additionalParameters
    (21) additionalParameters -> . empty
    (75) empty -> .

    COMMA           shift and go to state 69
    RPAREN          reduce using rule 75 (empty -> .)

    empty                          shift and go to state 70
    additionalParameters           shift and go to state 126

state 102

    (40) doStatement -> DO subroutineCall . SEMICOLON

    SEMICOLON       shift and go to state 127


state 103

    (54) subroutineCall -> name . LPAREN expressionList RPAREN
    (55) subroutineCall -> name . DOT name LPAREN expressionList RPAREN

    LPAREN          shift and go to state 129
    DOT             shift and go to state 128


state 104

    (22) subroutineBody -> LCURLY varDecs statements RCURLY .

    CONSTRUCTOR     reduce using rule 22 (subroutineBody -> LCURLY varDecs statements RCURLY .)
    FUNCTION        reduce using rule 22 (subroutineBody -> LCURLY varDecs statements RCURLY .)
    METHOD          reduce using rule 22 (subroutineBody -> LCURLY varDecs statements RCURLY .)
    RCURLY          reduce using rule 22 (subroutineBody -> LCURLY varDecs statements RCURLY .)


state 105

    (39) whileStatement -> WHILE LPAREN . expression RPAREN LCURLY statements RCURLY
    (43) expression -> . term opTerms
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 116
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107
    subroutineCall                 shift and go to state 113
    expression                     shift and go to state 130

state 106

    (47) term -> LPAREN . expression RPAREN
    (43) expression -> . term opTerms
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 116
    subroutineCall                 shift and go to state 113
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107
    expression                     shift and go to state 131

state 107

    (51) term -> keywordConstant .

    PLUS            reduce using rule 51 (term -> keywordConstant .)
    MINUS           reduce using rule 51 (term -> keywordConstant .)
    TIMES           reduce using rule 51 (term -> keywordConstant .)
    DIVIDE          reduce using rule 51 (term -> keywordConstant .)
    AMP             reduce using rule 51 (term -> keywordConstant .)
    PIPE            reduce using rule 51 (term -> keywordConstant .)
    LT              reduce using rule 51 (term -> keywordConstant .)
    GT              reduce using rule 51 (term -> keywordConstant .)
    EQ              reduce using rule 51 (term -> keywordConstant .)
    SEMICOLON       reduce using rule 51 (term -> keywordConstant .)
    COMMA           reduce using rule 51 (term -> keywordConstant .)
    RPAREN          reduce using rule 51 (term -> keywordConstant .)
    RSQUARE         reduce using rule 51 (term -> keywordConstant .)


state 108

    (73) keywordConstant -> NULL .

    PLUS            reduce using rule 73 (keywordConstant -> NULL .)
    MINUS           reduce using rule 73 (keywordConstant -> NULL .)
    TIMES           reduce using rule 73 (keywordConstant -> NULL .)
    DIVIDE          reduce using rule 73 (keywordConstant -> NULL .)
    AMP             reduce using rule 73 (keywordConstant -> NULL .)
    PIPE            reduce using rule 73 (keywordConstant -> NULL .)
    LT              reduce using rule 73 (keywordConstant -> NULL .)
    GT              reduce using rule 73 (keywordConstant -> NULL .)
    EQ              reduce using rule 73 (keywordConstant -> NULL .)
    SEMICOLON       reduce using rule 73 (keywordConstant -> NULL .)
    RPAREN          reduce using rule 73 (keywordConstant -> NULL .)
    COMMA           reduce using rule 73 (keywordConstant -> NULL .)
    RSQUARE         reduce using rule 73 (keywordConstant -> NULL .)


state 109

    (71) keywordConstant -> TRUE .

    PLUS            reduce using rule 71 (keywordConstant -> TRUE .)
    MINUS           reduce using rule 71 (keywordConstant -> TRUE .)
    TIMES           reduce using rule 71 (keywordConstant -> TRUE .)
    DIVIDE          reduce using rule 71 (keywordConstant -> TRUE .)
    AMP             reduce using rule 71 (keywordConstant -> TRUE .)
    PIPE            reduce using rule 71 (keywordConstant -> TRUE .)
    LT              reduce using rule 71 (keywordConstant -> TRUE .)
    GT              reduce using rule 71 (keywordConstant -> TRUE .)
    EQ              reduce using rule 71 (keywordConstant -> TRUE .)
    SEMICOLON       reduce using rule 71 (keywordConstant -> TRUE .)
    RPAREN          reduce using rule 71 (keywordConstant -> TRUE .)
    COMMA           reduce using rule 71 (keywordConstant -> TRUE .)
    RSQUARE         reduce using rule 71 (keywordConstant -> TRUE .)


state 110

    (69) unaryOp -> MINUS .

    INT_CONST       reduce using rule 69 (unaryOp -> MINUS .)
    LPAREN          reduce using rule 69 (unaryOp -> MINUS .)
    STRING_CONST    reduce using rule 69 (unaryOp -> MINUS .)
    MINUS           reduce using rule 69 (unaryOp -> MINUS .)
    TILDE           reduce using rule 69 (unaryOp -> MINUS .)
    IDENTIFIER      reduce using rule 69 (unaryOp -> MINUS .)
    TRUE            reduce using rule 69 (unaryOp -> MINUS .)
    FALSE           reduce using rule 69 (unaryOp -> MINUS .)
    NULL            reduce using rule 69 (unaryOp -> MINUS .)
    THIS            reduce using rule 69 (unaryOp -> MINUS .)


state 111

    (52) term -> STRING_CONST .

    PLUS            reduce using rule 52 (term -> STRING_CONST .)
    MINUS           reduce using rule 52 (term -> STRING_CONST .)
    TIMES           reduce using rule 52 (term -> STRING_CONST .)
    DIVIDE          reduce using rule 52 (term -> STRING_CONST .)
    AMP             reduce using rule 52 (term -> STRING_CONST .)
    PIPE            reduce using rule 52 (term -> STRING_CONST .)
    LT              reduce using rule 52 (term -> STRING_CONST .)
    GT              reduce using rule 52 (term -> STRING_CONST .)
    EQ              reduce using rule 52 (term -> STRING_CONST .)
    SEMICOLON       reduce using rule 52 (term -> STRING_CONST .)
    COMMA           reduce using rule 52 (term -> STRING_CONST .)
    RPAREN          reduce using rule 52 (term -> STRING_CONST .)
    RSQUARE         reduce using rule 52 (term -> STRING_CONST .)


state 112

    (46) term -> INT_CONST .

    PLUS            reduce using rule 46 (term -> INT_CONST .)
    MINUS           reduce using rule 46 (term -> INT_CONST .)
    TIMES           reduce using rule 46 (term -> INT_CONST .)
    DIVIDE          reduce using rule 46 (term -> INT_CONST .)
    AMP             reduce using rule 46 (term -> INT_CONST .)
    PIPE            reduce using rule 46 (term -> INT_CONST .)
    LT              reduce using rule 46 (term -> INT_CONST .)
    GT              reduce using rule 46 (term -> INT_CONST .)
    EQ              reduce using rule 46 (term -> INT_CONST .)
    SEMICOLON       reduce using rule 46 (term -> INT_CONST .)
    COMMA           reduce using rule 46 (term -> INT_CONST .)
    RPAREN          reduce using rule 46 (term -> INT_CONST .)
    RSQUARE         reduce using rule 46 (term -> INT_CONST .)


state 113

    (49) term -> subroutineCall .

    PLUS            reduce using rule 49 (term -> subroutineCall .)
    MINUS           reduce using rule 49 (term -> subroutineCall .)
    TIMES           reduce using rule 49 (term -> subroutineCall .)
    DIVIDE          reduce using rule 49 (term -> subroutineCall .)
    AMP             reduce using rule 49 (term -> subroutineCall .)
    PIPE            reduce using rule 49 (term -> subroutineCall .)
    LT              reduce using rule 49 (term -> subroutineCall .)
    GT              reduce using rule 49 (term -> subroutineCall .)
    EQ              reduce using rule 49 (term -> subroutineCall .)
    SEMICOLON       reduce using rule 49 (term -> subroutineCall .)
    COMMA           reduce using rule 49 (term -> subroutineCall .)
    RPAREN          reduce using rule 49 (term -> subroutineCall .)
    RSQUARE         reduce using rule 49 (term -> subroutineCall .)


state 114

    (41) returnStatement -> RETURN SEMICOLON .

    LET             reduce using rule 41 (returnStatement -> RETURN SEMICOLON .)
    IF              reduce using rule 41 (returnStatement -> RETURN SEMICOLON .)
    WHILE           reduce using rule 41 (returnStatement -> RETURN SEMICOLON .)
    DO              reduce using rule 41 (returnStatement -> RETURN SEMICOLON .)
    RETURN          reduce using rule 41 (returnStatement -> RETURN SEMICOLON .)
    RCURLY          reduce using rule 41 (returnStatement -> RETURN SEMICOLON .)


state 115

    (70) unaryOp -> TILDE .

    INT_CONST       reduce using rule 70 (unaryOp -> TILDE .)
    LPAREN          reduce using rule 70 (unaryOp -> TILDE .)
    STRING_CONST    reduce using rule 70 (unaryOp -> TILDE .)
    MINUS           reduce using rule 70 (unaryOp -> TILDE .)
    TILDE           reduce using rule 70 (unaryOp -> TILDE .)
    IDENTIFIER      reduce using rule 70 (unaryOp -> TILDE .)
    TRUE            reduce using rule 70 (unaryOp -> TILDE .)
    FALSE           reduce using rule 70 (unaryOp -> TILDE .)
    NULL            reduce using rule 70 (unaryOp -> TILDE .)
    THIS            reduce using rule 70 (unaryOp -> TILDE .)


state 116

    (43) expression -> term . opTerms
    (44) opTerms -> . op term opTerms
    (45) opTerms -> . empty
    (60) op -> . PLUS
    (61) op -> . MINUS
    (62) op -> . TIMES
    (63) op -> . DIVIDE
    (64) op -> . AMP
    (65) op -> . PIPE
    (66) op -> . LT
    (67) op -> . GT
    (68) op -> . EQ
    (75) empty -> .

    PLUS            shift and go to state 137
    MINUS           shift and go to state 141
    TIMES           shift and go to state 134
    DIVIDE          shift and go to state 133
    AMP             shift and go to state 138
    PIPE            shift and go to state 135
    LT              shift and go to state 136
    GT              shift and go to state 132
    EQ              shift and go to state 140
    SEMICOLON       reduce using rule 75 (empty -> .)
    RPAREN          reduce using rule 75 (empty -> .)
    COMMA           reduce using rule 75 (empty -> .)
    RSQUARE         reduce using rule 75 (empty -> .)

    opTerms                        shift and go to state 139
    empty                          shift and go to state 142
    op                             shift and go to state 143

state 117

    (72) keywordConstant -> FALSE .

    PLUS            reduce using rule 72 (keywordConstant -> FALSE .)
    MINUS           reduce using rule 72 (keywordConstant -> FALSE .)
    TIMES           reduce using rule 72 (keywordConstant -> FALSE .)
    DIVIDE          reduce using rule 72 (keywordConstant -> FALSE .)
    AMP             reduce using rule 72 (keywordConstant -> FALSE .)
    PIPE            reduce using rule 72 (keywordConstant -> FALSE .)
    LT              reduce using rule 72 (keywordConstant -> FALSE .)
    GT              reduce using rule 72 (keywordConstant -> FALSE .)
    EQ              reduce using rule 72 (keywordConstant -> FALSE .)
    SEMICOLON       reduce using rule 72 (keywordConstant -> FALSE .)
    RPAREN          reduce using rule 72 (keywordConstant -> FALSE .)
    COMMA           reduce using rule 72 (keywordConstant -> FALSE .)
    RSQUARE         reduce using rule 72 (keywordConstant -> FALSE .)


state 118

    (50) term -> name .
    (53) term -> name . LSQUARE expression RSQUARE
    (54) subroutineCall -> name . LPAREN expressionList RPAREN
    (55) subroutineCall -> name . DOT name LPAREN expressionList RPAREN

    PLUS            reduce using rule 50 (term -> name .)
    MINUS           reduce using rule 50 (term -> name .)
    TIMES           reduce using rule 50 (term -> name .)
    DIVIDE          reduce using rule 50 (term -> name .)
    AMP             reduce using rule 50 (term -> name .)
    PIPE            reduce using rule 50 (term -> name .)
    LT              reduce using rule 50 (term -> name .)
    GT              reduce using rule 50 (term -> name .)
    EQ              reduce using rule 50 (term -> name .)
    SEMICOLON       reduce using rule 50 (term -> name .)
    COMMA           reduce using rule 50 (term -> name .)
    RPAREN          reduce using rule 50 (term -> name .)
    RSQUARE         reduce using rule 50 (term -> name .)
    LSQUARE         shift and go to state 144
    LPAREN          shift and go to state 129
    DOT             shift and go to state 128


state 119

    (48) term -> unaryOp . term
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 145
    subroutineCall                 shift and go to state 113
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107

state 120

    (74) keywordConstant -> THIS .

    PLUS            reduce using rule 74 (keywordConstant -> THIS .)
    MINUS           reduce using rule 74 (keywordConstant -> THIS .)
    TIMES           reduce using rule 74 (keywordConstant -> THIS .)
    DIVIDE          reduce using rule 74 (keywordConstant -> THIS .)
    AMP             reduce using rule 74 (keywordConstant -> THIS .)
    PIPE            reduce using rule 74 (keywordConstant -> THIS .)
    LT              reduce using rule 74 (keywordConstant -> THIS .)
    GT              reduce using rule 74 (keywordConstant -> THIS .)
    EQ              reduce using rule 74 (keywordConstant -> THIS .)
    SEMICOLON       reduce using rule 74 (keywordConstant -> THIS .)
    RPAREN          reduce using rule 74 (keywordConstant -> THIS .)
    COMMA           reduce using rule 74 (keywordConstant -> THIS .)
    RSQUARE         reduce using rule 74 (keywordConstant -> THIS .)


state 121

    (42) returnStatement -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 146


state 122

    (28) statements -> statement statements .

    RCURLY          reduce using rule 28 (statements -> statement statements .)


state 123

    (37) ifStatement -> IF LPAREN . expression RPAREN LCURLY statements RCURLY
    (38) ifStatement -> IF LPAREN . expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (43) expression -> . term opTerms
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 116
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107
    subroutineCall                 shift and go to state 113
    expression                     shift and go to state 147

state 124

    (35) letStatement -> LET name . EQ expression SEMICOLON
    (36) letStatement -> LET name . LSQUARE expression RSQUARE EQ expression SEMICOLON

    EQ              shift and go to state 149
    LSQUARE         shift and go to state 148


state 125

    (23) varDecs -> VAR type name . commaVarNames SEMICOLON varDecs
    (25) commaVarNames -> . COMMA name commaVarNames
    (26) commaVarNames -> . empty
    (75) empty -> .

    COMMA           shift and go to state 150
    SEMICOLON       reduce using rule 75 (empty -> .)

    empty                          shift and go to state 152
    commaVarNames                  shift and go to state 151

state 126

    (20) additionalParameters -> COMMA type name additionalParameters .

    RPAREN          reduce using rule 20 (additionalParameters -> COMMA type name additionalParameters .)


state 127

    (40) doStatement -> DO subroutineCall SEMICOLON .

    LET             reduce using rule 40 (doStatement -> DO subroutineCall SEMICOLON .)
    IF              reduce using rule 40 (doStatement -> DO subroutineCall SEMICOLON .)
    WHILE           reduce using rule 40 (doStatement -> DO subroutineCall SEMICOLON .)
    DO              reduce using rule 40 (doStatement -> DO subroutineCall SEMICOLON .)
    RETURN          reduce using rule 40 (doStatement -> DO subroutineCall SEMICOLON .)
    RCURLY          reduce using rule 40 (doStatement -> DO subroutineCall SEMICOLON .)


state 128

    (55) subroutineCall -> name DOT . name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 153

state 129

    (54) subroutineCall -> name LPAREN . expressionList RPAREN
    (56) expressionList -> . expression commaExpressions
    (57) expressionList -> . empty
    (43) expression -> . term opTerms
    (75) empty -> .
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    RPAREN          reduce using rule 75 (empty -> .)
    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 116
    subroutineCall                 shift and go to state 113
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107
    expressionList                 shift and go to state 154
    expression                     shift and go to state 156
    empty                          shift and go to state 155

state 130

    (39) whileStatement -> WHILE LPAREN expression . RPAREN LCURLY statements RCURLY

    RPAREN          shift and go to state 157


state 131

    (47) term -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 158


state 132

    (67) op -> GT .

    INT_CONST       reduce using rule 67 (op -> GT .)
    LPAREN          reduce using rule 67 (op -> GT .)
    STRING_CONST    reduce using rule 67 (op -> GT .)
    MINUS           reduce using rule 67 (op -> GT .)
    TILDE           reduce using rule 67 (op -> GT .)
    IDENTIFIER      reduce using rule 67 (op -> GT .)
    TRUE            reduce using rule 67 (op -> GT .)
    FALSE           reduce using rule 67 (op -> GT .)
    NULL            reduce using rule 67 (op -> GT .)
    THIS            reduce using rule 67 (op -> GT .)


state 133

    (63) op -> DIVIDE .

    INT_CONST       reduce using rule 63 (op -> DIVIDE .)
    LPAREN          reduce using rule 63 (op -> DIVIDE .)
    STRING_CONST    reduce using rule 63 (op -> DIVIDE .)
    MINUS           reduce using rule 63 (op -> DIVIDE .)
    TILDE           reduce using rule 63 (op -> DIVIDE .)
    IDENTIFIER      reduce using rule 63 (op -> DIVIDE .)
    TRUE            reduce using rule 63 (op -> DIVIDE .)
    FALSE           reduce using rule 63 (op -> DIVIDE .)
    NULL            reduce using rule 63 (op -> DIVIDE .)
    THIS            reduce using rule 63 (op -> DIVIDE .)


state 134

    (62) op -> TIMES .

    INT_CONST       reduce using rule 62 (op -> TIMES .)
    LPAREN          reduce using rule 62 (op -> TIMES .)
    STRING_CONST    reduce using rule 62 (op -> TIMES .)
    MINUS           reduce using rule 62 (op -> TIMES .)
    TILDE           reduce using rule 62 (op -> TIMES .)
    IDENTIFIER      reduce using rule 62 (op -> TIMES .)
    TRUE            reduce using rule 62 (op -> TIMES .)
    FALSE           reduce using rule 62 (op -> TIMES .)
    NULL            reduce using rule 62 (op -> TIMES .)
    THIS            reduce using rule 62 (op -> TIMES .)


state 135

    (65) op -> PIPE .

    INT_CONST       reduce using rule 65 (op -> PIPE .)
    LPAREN          reduce using rule 65 (op -> PIPE .)
    STRING_CONST    reduce using rule 65 (op -> PIPE .)
    MINUS           reduce using rule 65 (op -> PIPE .)
    TILDE           reduce using rule 65 (op -> PIPE .)
    IDENTIFIER      reduce using rule 65 (op -> PIPE .)
    TRUE            reduce using rule 65 (op -> PIPE .)
    FALSE           reduce using rule 65 (op -> PIPE .)
    NULL            reduce using rule 65 (op -> PIPE .)
    THIS            reduce using rule 65 (op -> PIPE .)


state 136

    (66) op -> LT .

    INT_CONST       reduce using rule 66 (op -> LT .)
    LPAREN          reduce using rule 66 (op -> LT .)
    STRING_CONST    reduce using rule 66 (op -> LT .)
    MINUS           reduce using rule 66 (op -> LT .)
    TILDE           reduce using rule 66 (op -> LT .)
    IDENTIFIER      reduce using rule 66 (op -> LT .)
    TRUE            reduce using rule 66 (op -> LT .)
    FALSE           reduce using rule 66 (op -> LT .)
    NULL            reduce using rule 66 (op -> LT .)
    THIS            reduce using rule 66 (op -> LT .)


state 137

    (60) op -> PLUS .

    INT_CONST       reduce using rule 60 (op -> PLUS .)
    LPAREN          reduce using rule 60 (op -> PLUS .)
    STRING_CONST    reduce using rule 60 (op -> PLUS .)
    MINUS           reduce using rule 60 (op -> PLUS .)
    TILDE           reduce using rule 60 (op -> PLUS .)
    IDENTIFIER      reduce using rule 60 (op -> PLUS .)
    TRUE            reduce using rule 60 (op -> PLUS .)
    FALSE           reduce using rule 60 (op -> PLUS .)
    NULL            reduce using rule 60 (op -> PLUS .)
    THIS            reduce using rule 60 (op -> PLUS .)


state 138

    (64) op -> AMP .

    INT_CONST       reduce using rule 64 (op -> AMP .)
    LPAREN          reduce using rule 64 (op -> AMP .)
    STRING_CONST    reduce using rule 64 (op -> AMP .)
    MINUS           reduce using rule 64 (op -> AMP .)
    TILDE           reduce using rule 64 (op -> AMP .)
    IDENTIFIER      reduce using rule 64 (op -> AMP .)
    TRUE            reduce using rule 64 (op -> AMP .)
    FALSE           reduce using rule 64 (op -> AMP .)
    NULL            reduce using rule 64 (op -> AMP .)
    THIS            reduce using rule 64 (op -> AMP .)


state 139

    (43) expression -> term opTerms .

    COMMA           reduce using rule 43 (expression -> term opTerms .)
    RPAREN          reduce using rule 43 (expression -> term opTerms .)
    RSQUARE         reduce using rule 43 (expression -> term opTerms .)
    SEMICOLON       reduce using rule 43 (expression -> term opTerms .)


state 140

    (68) op -> EQ .

    INT_CONST       reduce using rule 68 (op -> EQ .)
    LPAREN          reduce using rule 68 (op -> EQ .)
    STRING_CONST    reduce using rule 68 (op -> EQ .)
    MINUS           reduce using rule 68 (op -> EQ .)
    TILDE           reduce using rule 68 (op -> EQ .)
    IDENTIFIER      reduce using rule 68 (op -> EQ .)
    TRUE            reduce using rule 68 (op -> EQ .)
    FALSE           reduce using rule 68 (op -> EQ .)
    NULL            reduce using rule 68 (op -> EQ .)
    THIS            reduce using rule 68 (op -> EQ .)


state 141

    (61) op -> MINUS .

    INT_CONST       reduce using rule 61 (op -> MINUS .)
    LPAREN          reduce using rule 61 (op -> MINUS .)
    STRING_CONST    reduce using rule 61 (op -> MINUS .)
    MINUS           reduce using rule 61 (op -> MINUS .)
    TILDE           reduce using rule 61 (op -> MINUS .)
    IDENTIFIER      reduce using rule 61 (op -> MINUS .)
    TRUE            reduce using rule 61 (op -> MINUS .)
    FALSE           reduce using rule 61 (op -> MINUS .)
    NULL            reduce using rule 61 (op -> MINUS .)
    THIS            reduce using rule 61 (op -> MINUS .)


state 142

    (45) opTerms -> empty .

    SEMICOLON       reduce using rule 45 (opTerms -> empty .)
    RPAREN          reduce using rule 45 (opTerms -> empty .)
    COMMA           reduce using rule 45 (opTerms -> empty .)
    RSQUARE         reduce using rule 45 (opTerms -> empty .)


state 143

    (44) opTerms -> op . term opTerms
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 159
    subroutineCall                 shift and go to state 113
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107

state 144

    (53) term -> name LSQUARE . expression RSQUARE
    (43) expression -> . term opTerms
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 116
    subroutineCall                 shift and go to state 113
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107
    expression                     shift and go to state 160

state 145

    (48) term -> unaryOp term .

    PLUS            reduce using rule 48 (term -> unaryOp term .)
    MINUS           reduce using rule 48 (term -> unaryOp term .)
    TIMES           reduce using rule 48 (term -> unaryOp term .)
    DIVIDE          reduce using rule 48 (term -> unaryOp term .)
    AMP             reduce using rule 48 (term -> unaryOp term .)
    PIPE            reduce using rule 48 (term -> unaryOp term .)
    LT              reduce using rule 48 (term -> unaryOp term .)
    GT              reduce using rule 48 (term -> unaryOp term .)
    EQ              reduce using rule 48 (term -> unaryOp term .)
    SEMICOLON       reduce using rule 48 (term -> unaryOp term .)
    COMMA           reduce using rule 48 (term -> unaryOp term .)
    RPAREN          reduce using rule 48 (term -> unaryOp term .)
    RSQUARE         reduce using rule 48 (term -> unaryOp term .)


state 146

    (42) returnStatement -> RETURN expression SEMICOLON .

    LET             reduce using rule 42 (returnStatement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 42 (returnStatement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 42 (returnStatement -> RETURN expression SEMICOLON .)
    DO              reduce using rule 42 (returnStatement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 42 (returnStatement -> RETURN expression SEMICOLON .)
    RCURLY          reduce using rule 42 (returnStatement -> RETURN expression SEMICOLON .)


state 147

    (37) ifStatement -> IF LPAREN expression . RPAREN LCURLY statements RCURLY
    (38) ifStatement -> IF LPAREN expression . RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY

    RPAREN          shift and go to state 161


state 148

    (36) letStatement -> LET name LSQUARE . expression RSQUARE EQ expression SEMICOLON
    (43) expression -> . term opTerms
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 116
    subroutineCall                 shift and go to state 113
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107
    expression                     shift and go to state 162

state 149

    (35) letStatement -> LET name EQ . expression SEMICOLON
    (43) expression -> . term opTerms
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 116
    subroutineCall                 shift and go to state 113
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107
    expression                     shift and go to state 163

state 150

    (25) commaVarNames -> COMMA . name commaVarNames
    (27) name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 164

state 151

    (23) varDecs -> VAR type name commaVarNames . SEMICOLON varDecs

    SEMICOLON       shift and go to state 165


state 152

    (26) commaVarNames -> empty .

    SEMICOLON       reduce using rule 26 (commaVarNames -> empty .)


state 153

    (55) subroutineCall -> name DOT name . LPAREN expressionList RPAREN

    LPAREN          shift and go to state 166


state 154

    (54) subroutineCall -> name LPAREN expressionList . RPAREN

    RPAREN          shift and go to state 167


state 155

    (57) expressionList -> empty .

    RPAREN          reduce using rule 57 (expressionList -> empty .)


state 156

    (56) expressionList -> expression . commaExpressions
    (58) commaExpressions -> . COMMA expression commaExpressions
    (59) commaExpressions -> . empty
    (75) empty -> .

    COMMA           shift and go to state 168
    RPAREN          reduce using rule 75 (empty -> .)

    empty                          shift and go to state 169
    commaExpressions               shift and go to state 170

state 157

    (39) whileStatement -> WHILE LPAREN expression RPAREN . LCURLY statements RCURLY

    LCURLY          shift and go to state 171


state 158

    (47) term -> LPAREN expression RPAREN .

    PLUS            reduce using rule 47 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 47 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 47 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 47 (term -> LPAREN expression RPAREN .)
    AMP             reduce using rule 47 (term -> LPAREN expression RPAREN .)
    PIPE            reduce using rule 47 (term -> LPAREN expression RPAREN .)
    LT              reduce using rule 47 (term -> LPAREN expression RPAREN .)
    GT              reduce using rule 47 (term -> LPAREN expression RPAREN .)
    EQ              reduce using rule 47 (term -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 47 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 47 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 47 (term -> LPAREN expression RPAREN .)
    RSQUARE         reduce using rule 47 (term -> LPAREN expression RPAREN .)


state 159

    (44) opTerms -> op term . opTerms
    (44) opTerms -> . op term opTerms
    (45) opTerms -> . empty
    (60) op -> . PLUS
    (61) op -> . MINUS
    (62) op -> . TIMES
    (63) op -> . DIVIDE
    (64) op -> . AMP
    (65) op -> . PIPE
    (66) op -> . LT
    (67) op -> . GT
    (68) op -> . EQ
    (75) empty -> .

    PLUS            shift and go to state 137
    MINUS           shift and go to state 141
    TIMES           shift and go to state 134
    DIVIDE          shift and go to state 133
    AMP             shift and go to state 138
    PIPE            shift and go to state 135
    LT              shift and go to state 136
    GT              shift and go to state 132
    EQ              shift and go to state 140
    SEMICOLON       reduce using rule 75 (empty -> .)
    RPAREN          reduce using rule 75 (empty -> .)
    COMMA           reduce using rule 75 (empty -> .)
    RSQUARE         reduce using rule 75 (empty -> .)

    opTerms                        shift and go to state 172
    empty                          shift and go to state 142
    op                             shift and go to state 143

state 160

    (53) term -> name LSQUARE expression . RSQUARE

    RSQUARE         shift and go to state 173


state 161

    (37) ifStatement -> IF LPAREN expression RPAREN . LCURLY statements RCURLY
    (38) ifStatement -> IF LPAREN expression RPAREN . LCURLY statements RCURLY ELSE LCURLY statements RCURLY

    LCURLY          shift and go to state 174


state 162

    (36) letStatement -> LET name LSQUARE expression . RSQUARE EQ expression SEMICOLON

    RSQUARE         shift and go to state 175


state 163

    (35) letStatement -> LET name EQ expression . SEMICOLON

    SEMICOLON       shift and go to state 176


state 164

    (25) commaVarNames -> COMMA name . commaVarNames
    (25) commaVarNames -> . COMMA name commaVarNames
    (26) commaVarNames -> . empty
    (75) empty -> .

    COMMA           shift and go to state 150
    SEMICOLON       reduce using rule 75 (empty -> .)

    empty                          shift and go to state 152
    commaVarNames                  shift and go to state 177

state 165

    (23) varDecs -> VAR type name commaVarNames SEMICOLON . varDecs
    (23) varDecs -> . VAR type name commaVarNames SEMICOLON varDecs
    (24) varDecs -> . empty
    (75) empty -> .

    VAR             shift and go to state 78
    LET             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    DO              reduce using rule 75 (empty -> .)
    RETURN          reduce using rule 75 (empty -> .)
    RCURLY          reduce using rule 75 (empty -> .)

    varDecs                        shift and go to state 178
    empty                          shift and go to state 79

state 166

    (55) subroutineCall -> name DOT name LPAREN . expressionList RPAREN
    (56) expressionList -> . expression commaExpressions
    (57) expressionList -> . empty
    (43) expression -> . term opTerms
    (75) empty -> .
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    RPAREN          reduce using rule 75 (empty -> .)
    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 116
    subroutineCall                 shift and go to state 113
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107
    expressionList                 shift and go to state 179
    expression                     shift and go to state 156
    empty                          shift and go to state 155

state 167

    (54) subroutineCall -> name LPAREN expressionList RPAREN .

    PLUS            reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    MINUS           reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    TIMES           reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    DIVIDE          reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    AMP             reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    PIPE            reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    LT              reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    GT              reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    EQ              reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    RPAREN          reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    COMMA           reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    RSQUARE         reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)
    SEMICOLON       reduce using rule 54 (subroutineCall -> name LPAREN expressionList RPAREN .)


state 168

    (58) commaExpressions -> COMMA . expression commaExpressions
    (43) expression -> . term opTerms
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 116
    subroutineCall                 shift and go to state 113
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107
    expression                     shift and go to state 180

state 169

    (59) commaExpressions -> empty .

    RPAREN          reduce using rule 59 (commaExpressions -> empty .)


state 170

    (56) expressionList -> expression commaExpressions .

    RPAREN          reduce using rule 56 (expressionList -> expression commaExpressions .)


state 171

    (39) whileStatement -> WHILE LPAREN expression RPAREN LCURLY . statements RCURLY
    (28) statements -> . statement statements
    (29) statements -> . empty
    (30) statement -> . letStatement
    (31) statement -> . ifStatement
    (32) statement -> . whileStatement
    (33) statement -> . doStatement
    (34) statement -> . returnStatement
    (75) empty -> .
    (35) letStatement -> . LET name EQ expression SEMICOLON
    (36) letStatement -> . LET name LSQUARE expression RSQUARE EQ expression SEMICOLON
    (37) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY
    (38) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (39) whileStatement -> . WHILE LPAREN expression RPAREN LCURLY statements RCURLY
    (40) doStatement -> . DO subroutineCall SEMICOLON
    (41) returnStatement -> . RETURN SEMICOLON
    (42) returnStatement -> . RETURN expression SEMICOLON

    RCURLY          reduce using rule 75 (empty -> .)
    LET             shift and go to state 99
    IF              shift and go to state 97
    WHILE           shift and go to state 89
    DO              shift and go to state 87
    RETURN          shift and go to state 90

    statements                     shift and go to state 181
    doStatement                    shift and go to state 91
    whileStatement                 shift and go to state 95
    letStatement                   shift and go to state 98
    statement                      shift and go to state 92
    returnStatement                shift and go to state 96
    empty                          shift and go to state 94
    ifStatement                    shift and go to state 93

state 172

    (44) opTerms -> op term opTerms .

    SEMICOLON       reduce using rule 44 (opTerms -> op term opTerms .)
    RPAREN          reduce using rule 44 (opTerms -> op term opTerms .)
    COMMA           reduce using rule 44 (opTerms -> op term opTerms .)
    RSQUARE         reduce using rule 44 (opTerms -> op term opTerms .)


state 173

    (53) term -> name LSQUARE expression RSQUARE .

    PLUS            reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    MINUS           reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    TIMES           reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    DIVIDE          reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    AMP             reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    PIPE            reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    LT              reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    GT              reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    EQ              reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    SEMICOLON       reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    COMMA           reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    RPAREN          reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)
    RSQUARE         reduce using rule 53 (term -> name LSQUARE expression RSQUARE .)


state 174

    (37) ifStatement -> IF LPAREN expression RPAREN LCURLY . statements RCURLY
    (38) ifStatement -> IF LPAREN expression RPAREN LCURLY . statements RCURLY ELSE LCURLY statements RCURLY
    (28) statements -> . statement statements
    (29) statements -> . empty
    (30) statement -> . letStatement
    (31) statement -> . ifStatement
    (32) statement -> . whileStatement
    (33) statement -> . doStatement
    (34) statement -> . returnStatement
    (75) empty -> .
    (35) letStatement -> . LET name EQ expression SEMICOLON
    (36) letStatement -> . LET name LSQUARE expression RSQUARE EQ expression SEMICOLON
    (37) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY
    (38) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (39) whileStatement -> . WHILE LPAREN expression RPAREN LCURLY statements RCURLY
    (40) doStatement -> . DO subroutineCall SEMICOLON
    (41) returnStatement -> . RETURN SEMICOLON
    (42) returnStatement -> . RETURN expression SEMICOLON

    RCURLY          reduce using rule 75 (empty -> .)
    LET             shift and go to state 99
    IF              shift and go to state 97
    WHILE           shift and go to state 89
    DO              shift and go to state 87
    RETURN          shift and go to state 90

    statements                     shift and go to state 182
    doStatement                    shift and go to state 91
    whileStatement                 shift and go to state 95
    letStatement                   shift and go to state 98
    statement                      shift and go to state 92
    returnStatement                shift and go to state 96
    empty                          shift and go to state 94
    ifStatement                    shift and go to state 93

state 175

    (36) letStatement -> LET name LSQUARE expression RSQUARE . EQ expression SEMICOLON

    EQ              shift and go to state 183


state 176

    (35) letStatement -> LET name EQ expression SEMICOLON .

    LET             reduce using rule 35 (letStatement -> LET name EQ expression SEMICOLON .)
    IF              reduce using rule 35 (letStatement -> LET name EQ expression SEMICOLON .)
    WHILE           reduce using rule 35 (letStatement -> LET name EQ expression SEMICOLON .)
    DO              reduce using rule 35 (letStatement -> LET name EQ expression SEMICOLON .)
    RETURN          reduce using rule 35 (letStatement -> LET name EQ expression SEMICOLON .)
    RCURLY          reduce using rule 35 (letStatement -> LET name EQ expression SEMICOLON .)


state 177

    (25) commaVarNames -> COMMA name commaVarNames .

    SEMICOLON       reduce using rule 25 (commaVarNames -> COMMA name commaVarNames .)


state 178

    (23) varDecs -> VAR type name commaVarNames SEMICOLON varDecs .

    LET             reduce using rule 23 (varDecs -> VAR type name commaVarNames SEMICOLON varDecs .)
    IF              reduce using rule 23 (varDecs -> VAR type name commaVarNames SEMICOLON varDecs .)
    WHILE           reduce using rule 23 (varDecs -> VAR type name commaVarNames SEMICOLON varDecs .)
    DO              reduce using rule 23 (varDecs -> VAR type name commaVarNames SEMICOLON varDecs .)
    RETURN          reduce using rule 23 (varDecs -> VAR type name commaVarNames SEMICOLON varDecs .)
    RCURLY          reduce using rule 23 (varDecs -> VAR type name commaVarNames SEMICOLON varDecs .)


state 179

    (55) subroutineCall -> name DOT name LPAREN expressionList . RPAREN

    RPAREN          shift and go to state 184


state 180

    (58) commaExpressions -> COMMA expression . commaExpressions
    (58) commaExpressions -> . COMMA expression commaExpressions
    (59) commaExpressions -> . empty
    (75) empty -> .

    COMMA           shift and go to state 168
    RPAREN          reduce using rule 75 (empty -> .)

    empty                          shift and go to state 169
    commaExpressions               shift and go to state 185

state 181

    (39) whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements . RCURLY

    RCURLY          shift and go to state 186


state 182

    (37) ifStatement -> IF LPAREN expression RPAREN LCURLY statements . RCURLY
    (38) ifStatement -> IF LPAREN expression RPAREN LCURLY statements . RCURLY ELSE LCURLY statements RCURLY

    RCURLY          shift and go to state 187


state 183

    (36) letStatement -> LET name LSQUARE expression RSQUARE EQ . expression SEMICOLON
    (43) expression -> . term opTerms
    (46) term -> . INT_CONST
    (47) term -> . LPAREN expression RPAREN
    (48) term -> . unaryOp term
    (49) term -> . subroutineCall
    (50) term -> . name
    (51) term -> . keywordConstant
    (52) term -> . STRING_CONST
    (53) term -> . name LSQUARE expression RSQUARE
    (69) unaryOp -> . MINUS
    (70) unaryOp -> . TILDE
    (54) subroutineCall -> . name LPAREN expressionList RPAREN
    (55) subroutineCall -> . name DOT name LPAREN expressionList RPAREN
    (27) name -> . IDENTIFIER
    (71) keywordConstant -> . TRUE
    (72) keywordConstant -> . FALSE
    (73) keywordConstant -> . NULL
    (74) keywordConstant -> . THIS

    INT_CONST       shift and go to state 112
    LPAREN          shift and go to state 106
    STRING_CONST    shift and go to state 111
    MINUS           shift and go to state 110
    TILDE           shift and go to state 115
    IDENTIFIER      shift and go to state 4
    TRUE            shift and go to state 109
    FALSE           shift and go to state 117
    NULL            shift and go to state 108
    THIS            shift and go to state 120

    term                           shift and go to state 116
    subroutineCall                 shift and go to state 113
    name                           shift and go to state 118
    unaryOp                        shift and go to state 119
    keywordConstant                shift and go to state 107
    expression                     shift and go to state 188

state 184

    (55) subroutineCall -> name DOT name LPAREN expressionList RPAREN .

    PLUS            reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    MINUS           reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    TIMES           reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    DIVIDE          reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    AMP             reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    PIPE            reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    LT              reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    GT              reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    EQ              reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    RPAREN          reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    COMMA           reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    RSQUARE         reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)
    SEMICOLON       reduce using rule 55 (subroutineCall -> name DOT name LPAREN expressionList RPAREN .)


state 185

    (58) commaExpressions -> COMMA expression commaExpressions .

    RPAREN          reduce using rule 58 (commaExpressions -> COMMA expression commaExpressions .)


state 186

    (39) whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .

    LET             reduce using rule 39 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)
    IF              reduce using rule 39 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)
    WHILE           reduce using rule 39 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)
    DO              reduce using rule 39 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)
    RETURN          reduce using rule 39 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)
    RCURLY          reduce using rule 39 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)


state 187

    (37) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .
    (38) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY . ELSE LCURLY statements RCURLY

    LET             reduce using rule 37 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    IF              reduce using rule 37 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    WHILE           reduce using rule 37 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    DO              reduce using rule 37 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    RETURN          reduce using rule 37 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    RCURLY          reduce using rule 37 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    ELSE            shift and go to state 189


state 188

    (36) letStatement -> LET name LSQUARE expression RSQUARE EQ expression . SEMICOLON

    SEMICOLON       shift and go to state 190


state 189

    (38) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE . LCURLY statements RCURLY

    LCURLY          shift and go to state 191


state 190

    (36) letStatement -> LET name LSQUARE expression RSQUARE EQ expression SEMICOLON .

    LET             reduce using rule 36 (letStatement -> LET name LSQUARE expression RSQUARE EQ expression SEMICOLON .)
    IF              reduce using rule 36 (letStatement -> LET name LSQUARE expression RSQUARE EQ expression SEMICOLON .)
    WHILE           reduce using rule 36 (letStatement -> LET name LSQUARE expression RSQUARE EQ expression SEMICOLON .)
    DO              reduce using rule 36 (letStatement -> LET name LSQUARE expression RSQUARE EQ expression SEMICOLON .)
    RETURN          reduce using rule 36 (letStatement -> LET name LSQUARE expression RSQUARE EQ expression SEMICOLON .)
    RCURLY          reduce using rule 36 (letStatement -> LET name LSQUARE expression RSQUARE EQ expression SEMICOLON .)


state 191

    (38) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY . statements RCURLY
    (28) statements -> . statement statements
    (29) statements -> . empty
    (30) statement -> . letStatement
    (31) statement -> . ifStatement
    (32) statement -> . whileStatement
    (33) statement -> . doStatement
    (34) statement -> . returnStatement
    (75) empty -> .
    (35) letStatement -> . LET name EQ expression SEMICOLON
    (36) letStatement -> . LET name LSQUARE expression RSQUARE EQ expression SEMICOLON
    (37) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY
    (38) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (39) whileStatement -> . WHILE LPAREN expression RPAREN LCURLY statements RCURLY
    (40) doStatement -> . DO subroutineCall SEMICOLON
    (41) returnStatement -> . RETURN SEMICOLON
    (42) returnStatement -> . RETURN expression SEMICOLON

    RCURLY          reduce using rule 75 (empty -> .)
    LET             shift and go to state 99
    IF              shift and go to state 97
    WHILE           shift and go to state 89
    DO              shift and go to state 87
    RETURN          shift and go to state 90

    statements                     shift and go to state 192
    doStatement                    shift and go to state 91
    whileStatement                 shift and go to state 95
    letStatement                   shift and go to state 98
    statement                      shift and go to state 92
    returnStatement                shift and go to state 96
    empty                          shift and go to state 94
    ifStatement                    shift and go to state 93

state 192

    (38) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements . RCURLY

    RCURLY          shift and go to state 193


state 193

    (38) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .

    LET             reduce using rule 38 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    IF              reduce using rule 38 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    WHILE           reduce using rule 38 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    DO              reduce using rule 38 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    RETURN          reduce using rule 38 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    RCURLY          reduce using rule 38 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)

