Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> class
Rule 1     class -> CLASS className LCURLY classVarDecs subroutineDecs RCURLY
Rule 2     classVarDecs -> STATIC type varName commaClassVarNames SEMICOLON classVarDecs
Rule 3     classVarDecs -> FIELD type varName commaClassVarNames SEMICOLON classVarDecs
Rule 4     classVarDecs -> empty
Rule 5     commaClassVarNames -> COMMA varName commaClassVarNames
Rule 6     commaClassVarNames -> empty
Rule 7     type -> INT
Rule 8     type -> CHAR
Rule 9     type -> BOOLEAN
Rule 10    type -> className
Rule 11    subroutineDecs -> CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 12    subroutineDecs -> CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 13    subroutineDecs -> FUNCTION VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 14    subroutineDecs -> FUNCTION type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 15    subroutineDecs -> METHOD VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 16    subroutineDecs -> METHOD type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
Rule 17    subroutineDecs -> empty
Rule 18    parameterList -> type varName additionalParameters
Rule 19    parameterList -> empty
Rule 20    additionalParameters -> COMMA type varName additionalParameters
Rule 21    additionalParameters -> empty
Rule 22    subroutineBody -> LCURLY varDecs statements RCURLY
Rule 23    varDecs -> VAR type varName commaVarNames SEMICOLON varDecs
Rule 24    varDecs -> empty
Rule 25    commaVarNames -> COMMA varName commaVarNames
Rule 26    commaVarNames -> empty
Rule 27    className -> IDENTIFIER
Rule 28    subroutineName -> IDENTIFIER
Rule 29    varName -> IDENTIFIER
Rule 30    statements -> statement statements
Rule 31    statements -> empty
Rule 32    statement -> letStatement
Rule 33    statement -> ifStatement
Rule 34    statement -> whileStatement
Rule 35    statement -> doStatement
Rule 36    statement -> returnStatement
Rule 37    letStatement -> LET varName EQ expression SEMICOLON
Rule 38    letStatement -> LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON
Rule 39    ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY
Rule 40    ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
Rule 41    whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY
Rule 42    doStatement -> DO subroutineCall SEMICOLON
Rule 43    returnStatement -> RETURN SEMICOLON
Rule 44    returnStatement -> RETURN expression SEMICOLON
Rule 45    expression -> term opTerms
Rule 46    opTerms -> op term opTerms
Rule 47    opTerms -> empty
Rule 48    term -> INT_CONST
Rule 49    term -> LPAREN expression RPAREN
Rule 50    term -> unaryOp term
Rule 51    term -> subroutineCall
Rule 52    term -> varName
Rule 53    term -> keywordConstant
Rule 54    term -> STRING_CONST
Rule 55    term -> varName LSQUARE expression RSQUARE
Rule 56    subroutineCall -> subroutineName LPAREN expressionList RPAREN
Rule 57    subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN
Rule 58    subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN
Rule 59    expressionList -> expression commaExpressions
Rule 60    expressionList -> empty
Rule 61    commaExpressions -> COMMA expression commaExpressions
Rule 62    commaExpressions -> empty
Rule 63    op -> PLUS
Rule 64    op -> MINUS
Rule 65    op -> TIMES
Rule 66    op -> DIVIDE
Rule 67    op -> AMP
Rule 68    op -> PIPE
Rule 69    op -> LT
Rule 70    op -> GT
Rule 71    op -> EQ
Rule 72    unaryOp -> MINUS
Rule 73    unaryOp -> TILDE
Rule 74    keywordConstant -> TRUE
Rule 75    keywordConstant -> FALSE
Rule 76    keywordConstant -> NULL
Rule 77    keywordConstant -> THIS
Rule 78    empty -> <empty>

Terminals, with rules where they appear

AMP                  : 67
BOOLEAN              : 9
CHAR                 : 8
CLASS                : 1
COMMA                : 5 20 25 61
CONSTRUCTOR          : 11 12
DIVIDE               : 66
DO                   : 42
DOT                  : 57 58
ELSE                 : 40
EQ                   : 37 38 71
FALSE                : 75
FIELD                : 3
FUNCTION             : 13 14
GT                   : 70
IDENTIFIER           : 27 28 29
IF                   : 39 40
INT                  : 7
INT_CONST            : 48
LCURLY               : 1 22 39 40 40 41
LET                  : 37 38
LPAREN               : 11 12 13 14 15 16 39 40 41 49 56 57 58
LSQUARE              : 38 55
LT                   : 69
METHOD               : 15 16
MINUS                : 64 72
NULL                 : 76
PIPE                 : 68
PLUS                 : 63
RCURLY               : 1 22 39 40 40 41
RETURN               : 43 44
RPAREN               : 11 12 13 14 15 16 39 40 41 49 56 57 58
RSQUARE              : 38 55
SEMICOLON            : 2 3 23 37 38 42 43 44
STATIC               : 2
STRING_CONST         : 54
THIS                 : 77
TILDE                : 73
TIMES                : 65
TRUE                 : 74
VAR                  : 23
VOID                 : 11 13 15
WHILE                : 41
error                : 

Nonterminals, with rules where they appear

additionalParameters : 18 20
class                : 0
className            : 1 10 57
classVarDecs         : 1 2 3
commaClassVarNames   : 2 3 5
commaExpressions     : 59 61
commaVarNames        : 23 25
doStatement          : 35
empty                : 4 6 17 19 21 24 26 31 47 60 62
expression           : 37 38 38 39 40 41 44 49 55 59 61
expressionList       : 56 57 58
ifStatement          : 33
keywordConstant      : 53
letStatement         : 32
op                   : 46
opTerms              : 45 46
parameterList        : 11 12 13 14 15 16
returnStatement      : 36
statement            : 30
statements           : 22 30 39 40 40 41
subroutineBody       : 11 12 13 14 15 16
subroutineCall       : 42 51
subroutineDecs       : 1 11 12 13 14 15 16
subroutineName       : 11 12 13 14 15 16 56 57 58
term                 : 45 46 50
type                 : 2 3 12 14 16 18 20 23
unaryOp              : 50
varDecs              : 22 23
varName              : 2 3 5 18 20 23 25 37 38 52 55 58
whileStatement       : 34

Parsing method: LALR

state 0

    (0) S' -> . class
    (1) class -> . CLASS className LCURLY classVarDecs subroutineDecs RCURLY

    CLASS           shift and go to state 1

    class                          shift and go to state 2

state 1

    (1) class -> CLASS . className LCURLY classVarDecs subroutineDecs RCURLY
    (27) className -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 3

state 2

    (0) S' -> class .



state 3

    (1) class -> CLASS className . LCURLY classVarDecs subroutineDecs RCURLY

    LCURLY          shift and go to state 5


state 4

    (27) className -> IDENTIFIER .

    IDENTIFIER      reduce using rule 27 (className -> IDENTIFIER .)
    LCURLY          reduce using rule 27 (className -> IDENTIFIER .)


state 5

    (1) class -> CLASS className LCURLY . classVarDecs subroutineDecs RCURLY
    (2) classVarDecs -> . STATIC type varName commaClassVarNames SEMICOLON classVarDecs
    (3) classVarDecs -> . FIELD type varName commaClassVarNames SEMICOLON classVarDecs
    (4) classVarDecs -> . empty
    (78) empty -> .

    STATIC          shift and go to state 8
    FIELD           shift and go to state 7
    CONSTRUCTOR     reduce using rule 78 (empty -> .)
    FUNCTION        reduce using rule 78 (empty -> .)
    METHOD          reduce using rule 78 (empty -> .)
    RCURLY          reduce using rule 78 (empty -> .)

    classVarDecs                   shift and go to state 6
    empty                          shift and go to state 9

state 6

    (1) class -> CLASS className LCURLY classVarDecs . subroutineDecs RCURLY
    (11) subroutineDecs -> . CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (78) empty -> .

    CONSTRUCTOR     shift and go to state 11
    FUNCTION        shift and go to state 10
    METHOD          shift and go to state 12
    RCURLY          reduce using rule 78 (empty -> .)

    subroutineDecs                 shift and go to state 13
    empty                          shift and go to state 14

state 7

    (3) classVarDecs -> FIELD . type varName commaClassVarNames SEMICOLON classVarDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (27) className -> . IDENTIFIER

    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    type                           shift and go to state 19

state 8

    (2) classVarDecs -> STATIC . type varName commaClassVarNames SEMICOLON classVarDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (27) className -> . IDENTIFIER

    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    type                           shift and go to state 20

state 9

    (4) classVarDecs -> empty .

    CONSTRUCTOR     reduce using rule 4 (classVarDecs -> empty .)
    FUNCTION        reduce using rule 4 (classVarDecs -> empty .)
    METHOD          reduce using rule 4 (classVarDecs -> empty .)
    RCURLY          reduce using rule 4 (classVarDecs -> empty .)


state 10

    (13) subroutineDecs -> FUNCTION . VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> FUNCTION . type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (27) className -> . IDENTIFIER

    VOID            shift and go to state 21
    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    type                           shift and go to state 22

state 11

    (11) subroutineDecs -> CONSTRUCTOR . VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> CONSTRUCTOR . type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (27) className -> . IDENTIFIER

    VOID            shift and go to state 23
    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    type                           shift and go to state 24

state 12

    (15) subroutineDecs -> METHOD . VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> METHOD . type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (27) className -> . IDENTIFIER

    VOID            shift and go to state 25
    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    type                           shift and go to state 26

state 13

    (1) class -> CLASS className LCURLY classVarDecs subroutineDecs . RCURLY

    RCURLY          shift and go to state 27


state 14

    (17) subroutineDecs -> empty .

    RCURLY          reduce using rule 17 (subroutineDecs -> empty .)


state 15

    (8) type -> CHAR .

    IDENTIFIER      reduce using rule 8 (type -> CHAR .)


state 16

    (7) type -> INT .

    IDENTIFIER      reduce using rule 7 (type -> INT .)


state 17

    (9) type -> BOOLEAN .

    IDENTIFIER      reduce using rule 9 (type -> BOOLEAN .)


state 18

    (10) type -> className .

    IDENTIFIER      reduce using rule 10 (type -> className .)


state 19

    (3) classVarDecs -> FIELD type . varName commaClassVarNames SEMICOLON classVarDecs
    (29) varName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 29

    varName                        shift and go to state 28

state 20

    (2) classVarDecs -> STATIC type . varName commaClassVarNames SEMICOLON classVarDecs
    (29) varName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 29

    varName                        shift and go to state 30

state 21

    (13) subroutineDecs -> FUNCTION VOID . subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (28) subroutineName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 32

    subroutineName                 shift and go to state 31

state 22

    (14) subroutineDecs -> FUNCTION type . subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (28) subroutineName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 32

    subroutineName                 shift and go to state 33

state 23

    (11) subroutineDecs -> CONSTRUCTOR VOID . subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (28) subroutineName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 32

    subroutineName                 shift and go to state 34

state 24

    (12) subroutineDecs -> CONSTRUCTOR type . subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (28) subroutineName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 32

    subroutineName                 shift and go to state 35

state 25

    (15) subroutineDecs -> METHOD VOID . subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (28) subroutineName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 32

    subroutineName                 shift and go to state 36

state 26

    (16) subroutineDecs -> METHOD type . subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (28) subroutineName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 32

    subroutineName                 shift and go to state 37

state 27

    (1) class -> CLASS className LCURLY classVarDecs subroutineDecs RCURLY .

    $end            reduce using rule 1 (class -> CLASS className LCURLY classVarDecs subroutineDecs RCURLY .)


state 28

    (3) classVarDecs -> FIELD type varName . commaClassVarNames SEMICOLON classVarDecs
    (5) commaClassVarNames -> . COMMA varName commaClassVarNames
    (6) commaClassVarNames -> . empty
    (78) empty -> .

    COMMA           shift and go to state 39
    SEMICOLON       reduce using rule 78 (empty -> .)

    empty                          shift and go to state 40
    commaClassVarNames             shift and go to state 38

state 29

    (29) varName -> IDENTIFIER .

    EQ              reduce using rule 29 (varName -> IDENTIFIER .)
    LSQUARE         reduce using rule 29 (varName -> IDENTIFIER .)
    COMMA           reduce using rule 29 (varName -> IDENTIFIER .)
    SEMICOLON       reduce using rule 29 (varName -> IDENTIFIER .)
    RPAREN          reduce using rule 29 (varName -> IDENTIFIER .)


state 30

    (2) classVarDecs -> STATIC type varName . commaClassVarNames SEMICOLON classVarDecs
    (5) commaClassVarNames -> . COMMA varName commaClassVarNames
    (6) commaClassVarNames -> . empty
    (78) empty -> .

    COMMA           shift and go to state 39
    SEMICOLON       reduce using rule 78 (empty -> .)

    empty                          shift and go to state 40
    commaClassVarNames             shift and go to state 41

state 31

    (13) subroutineDecs -> FUNCTION VOID subroutineName . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 42


state 32

    (28) subroutineName -> IDENTIFIER .

    LPAREN          reduce using rule 28 (subroutineName -> IDENTIFIER .)


state 33

    (14) subroutineDecs -> FUNCTION type subroutineName . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 43


state 34

    (11) subroutineDecs -> CONSTRUCTOR VOID subroutineName . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 44


state 35

    (12) subroutineDecs -> CONSTRUCTOR type subroutineName . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 45


state 36

    (15) subroutineDecs -> METHOD VOID subroutineName . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 46


state 37

    (16) subroutineDecs -> METHOD type subroutineName . LPAREN parameterList RPAREN subroutineBody subroutineDecs

    LPAREN          shift and go to state 47


state 38

    (3) classVarDecs -> FIELD type varName commaClassVarNames . SEMICOLON classVarDecs

    SEMICOLON       shift and go to state 48


state 39

    (5) commaClassVarNames -> COMMA . varName commaClassVarNames
    (29) varName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 29

    varName                        shift and go to state 49

state 40

    (6) commaClassVarNames -> empty .

    SEMICOLON       reduce using rule 6 (commaClassVarNames -> empty .)


state 41

    (2) classVarDecs -> STATIC type varName commaClassVarNames . SEMICOLON classVarDecs

    SEMICOLON       shift and go to state 50


state 42

    (13) subroutineDecs -> FUNCTION VOID subroutineName LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type varName additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (78) empty -> .
    (27) className -> . IDENTIFIER

    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    RPAREN          reduce using rule 78 (empty -> .)
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    parameterList                  shift and go to state 51
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 43

    (14) subroutineDecs -> FUNCTION type subroutineName LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type varName additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (78) empty -> .
    (27) className -> . IDENTIFIER

    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    RPAREN          reduce using rule 78 (empty -> .)
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    parameterList                  shift and go to state 54
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 44

    (11) subroutineDecs -> CONSTRUCTOR VOID subroutineName LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type varName additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (78) empty -> .
    (27) className -> . IDENTIFIER

    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    RPAREN          reduce using rule 78 (empty -> .)
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    parameterList                  shift and go to state 55
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 45

    (12) subroutineDecs -> CONSTRUCTOR type subroutineName LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type varName additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (78) empty -> .
    (27) className -> . IDENTIFIER

    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    RPAREN          reduce using rule 78 (empty -> .)
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    parameterList                  shift and go to state 56
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 46

    (15) subroutineDecs -> METHOD VOID subroutineName LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type varName additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (78) empty -> .
    (27) className -> . IDENTIFIER

    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    RPAREN          reduce using rule 78 (empty -> .)
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    parameterList                  shift and go to state 57
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 47

    (16) subroutineDecs -> METHOD type subroutineName LPAREN . parameterList RPAREN subroutineBody subroutineDecs
    (18) parameterList -> . type varName additionalParameters
    (19) parameterList -> . empty
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (78) empty -> .
    (27) className -> . IDENTIFIER

    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    RPAREN          reduce using rule 78 (empty -> .)
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    parameterList                  shift and go to state 58
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 48

    (3) classVarDecs -> FIELD type varName commaClassVarNames SEMICOLON . classVarDecs
    (2) classVarDecs -> . STATIC type varName commaClassVarNames SEMICOLON classVarDecs
    (3) classVarDecs -> . FIELD type varName commaClassVarNames SEMICOLON classVarDecs
    (4) classVarDecs -> . empty
    (78) empty -> .

    STATIC          shift and go to state 8
    FIELD           shift and go to state 7
    CONSTRUCTOR     reduce using rule 78 (empty -> .)
    FUNCTION        reduce using rule 78 (empty -> .)
    METHOD          reduce using rule 78 (empty -> .)
    RCURLY          reduce using rule 78 (empty -> .)

    classVarDecs                   shift and go to state 59
    empty                          shift and go to state 9

state 49

    (5) commaClassVarNames -> COMMA varName . commaClassVarNames
    (5) commaClassVarNames -> . COMMA varName commaClassVarNames
    (6) commaClassVarNames -> . empty
    (78) empty -> .

    COMMA           shift and go to state 39
    SEMICOLON       reduce using rule 78 (empty -> .)

    commaClassVarNames             shift and go to state 60
    empty                          shift and go to state 40

state 50

    (2) classVarDecs -> STATIC type varName commaClassVarNames SEMICOLON . classVarDecs
    (2) classVarDecs -> . STATIC type varName commaClassVarNames SEMICOLON classVarDecs
    (3) classVarDecs -> . FIELD type varName commaClassVarNames SEMICOLON classVarDecs
    (4) classVarDecs -> . empty
    (78) empty -> .

    STATIC          shift and go to state 8
    FIELD           shift and go to state 7
    CONSTRUCTOR     reduce using rule 78 (empty -> .)
    FUNCTION        reduce using rule 78 (empty -> .)
    METHOD          reduce using rule 78 (empty -> .)
    RCURLY          reduce using rule 78 (empty -> .)

    classVarDecs                   shift and go to state 61
    empty                          shift and go to state 9

state 51

    (13) subroutineDecs -> FUNCTION VOID subroutineName LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 62


state 52

    (18) parameterList -> type . varName additionalParameters
    (29) varName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 29

    varName                        shift and go to state 63

state 53

    (19) parameterList -> empty .

    RPAREN          reduce using rule 19 (parameterList -> empty .)


state 54

    (14) subroutineDecs -> FUNCTION type subroutineName LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 64


state 55

    (11) subroutineDecs -> CONSTRUCTOR VOID subroutineName LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 65


state 56

    (12) subroutineDecs -> CONSTRUCTOR type subroutineName LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 66


state 57

    (15) subroutineDecs -> METHOD VOID subroutineName LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 67


state 58

    (16) subroutineDecs -> METHOD type subroutineName LPAREN parameterList . RPAREN subroutineBody subroutineDecs

    RPAREN          shift and go to state 68


state 59

    (3) classVarDecs -> FIELD type varName commaClassVarNames SEMICOLON classVarDecs .

    CONSTRUCTOR     reduce using rule 3 (classVarDecs -> FIELD type varName commaClassVarNames SEMICOLON classVarDecs .)
    FUNCTION        reduce using rule 3 (classVarDecs -> FIELD type varName commaClassVarNames SEMICOLON classVarDecs .)
    METHOD          reduce using rule 3 (classVarDecs -> FIELD type varName commaClassVarNames SEMICOLON classVarDecs .)
    RCURLY          reduce using rule 3 (classVarDecs -> FIELD type varName commaClassVarNames SEMICOLON classVarDecs .)


state 60

    (5) commaClassVarNames -> COMMA varName commaClassVarNames .

    SEMICOLON       reduce using rule 5 (commaClassVarNames -> COMMA varName commaClassVarNames .)


state 61

    (2) classVarDecs -> STATIC type varName commaClassVarNames SEMICOLON classVarDecs .

    CONSTRUCTOR     reduce using rule 2 (classVarDecs -> STATIC type varName commaClassVarNames SEMICOLON classVarDecs .)
    FUNCTION        reduce using rule 2 (classVarDecs -> STATIC type varName commaClassVarNames SEMICOLON classVarDecs .)
    METHOD          reduce using rule 2 (classVarDecs -> STATIC type varName commaClassVarNames SEMICOLON classVarDecs .)
    RCURLY          reduce using rule 2 (classVarDecs -> STATIC type varName commaClassVarNames SEMICOLON classVarDecs .)


state 62

    (13) subroutineDecs -> FUNCTION VOID subroutineName LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 69

    subroutineBody                 shift and go to state 70

state 63

    (18) parameterList -> type varName . additionalParameters
    (20) additionalParameters -> . COMMA type varName additionalParameters
    (21) additionalParameters -> . empty
    (78) empty -> .

    COMMA           shift and go to state 71
    RPAREN          reduce using rule 78 (empty -> .)

    empty                          shift and go to state 72
    additionalParameters           shift and go to state 73

state 64

    (14) subroutineDecs -> FUNCTION type subroutineName LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 69

    subroutineBody                 shift and go to state 74

state 65

    (11) subroutineDecs -> CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 69

    subroutineBody                 shift and go to state 75

state 66

    (12) subroutineDecs -> CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 69

    subroutineBody                 shift and go to state 76

state 67

    (15) subroutineDecs -> METHOD VOID subroutineName LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 69

    subroutineBody                 shift and go to state 77

state 68

    (16) subroutineDecs -> METHOD type subroutineName LPAREN parameterList RPAREN . subroutineBody subroutineDecs
    (22) subroutineBody -> . LCURLY varDecs statements RCURLY

    LCURLY          shift and go to state 69

    subroutineBody                 shift and go to state 78

state 69

    (22) subroutineBody -> LCURLY . varDecs statements RCURLY
    (23) varDecs -> . VAR type varName commaVarNames SEMICOLON varDecs
    (24) varDecs -> . empty
    (78) empty -> .

    VAR             shift and go to state 80
    LET             reduce using rule 78 (empty -> .)
    IF              reduce using rule 78 (empty -> .)
    WHILE           reduce using rule 78 (empty -> .)
    DO              reduce using rule 78 (empty -> .)
    RETURN          reduce using rule 78 (empty -> .)
    RCURLY          reduce using rule 78 (empty -> .)

    varDecs                        shift and go to state 79
    empty                          shift and go to state 81

state 70

    (13) subroutineDecs -> FUNCTION VOID subroutineName LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (78) empty -> .

    CONSTRUCTOR     shift and go to state 11
    FUNCTION        shift and go to state 10
    METHOD          shift and go to state 12
    RCURLY          reduce using rule 78 (empty -> .)

    subroutineDecs                 shift and go to state 82
    empty                          shift and go to state 14

state 71

    (20) additionalParameters -> COMMA . type varName additionalParameters
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (27) className -> . IDENTIFIER

    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    type                           shift and go to state 83

state 72

    (21) additionalParameters -> empty .

    RPAREN          reduce using rule 21 (additionalParameters -> empty .)


state 73

    (18) parameterList -> type varName additionalParameters .

    RPAREN          reduce using rule 18 (parameterList -> type varName additionalParameters .)


state 74

    (14) subroutineDecs -> FUNCTION type subroutineName LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (78) empty -> .

    CONSTRUCTOR     shift and go to state 11
    FUNCTION        shift and go to state 10
    METHOD          shift and go to state 12
    RCURLY          reduce using rule 78 (empty -> .)

    subroutineDecs                 shift and go to state 84
    empty                          shift and go to state 14

state 75

    (11) subroutineDecs -> CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (78) empty -> .

    CONSTRUCTOR     shift and go to state 11
    FUNCTION        shift and go to state 10
    METHOD          shift and go to state 12
    RCURLY          reduce using rule 78 (empty -> .)

    subroutineDecs                 shift and go to state 85
    empty                          shift and go to state 14

state 76

    (12) subroutineDecs -> CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (78) empty -> .

    CONSTRUCTOR     shift and go to state 11
    FUNCTION        shift and go to state 10
    METHOD          shift and go to state 12
    RCURLY          reduce using rule 78 (empty -> .)

    subroutineDecs                 shift and go to state 86
    empty                          shift and go to state 14

state 77

    (15) subroutineDecs -> METHOD VOID subroutineName LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (78) empty -> .

    CONSTRUCTOR     shift and go to state 11
    FUNCTION        shift and go to state 10
    METHOD          shift and go to state 12
    RCURLY          reduce using rule 78 (empty -> .)

    subroutineDecs                 shift and go to state 87
    empty                          shift and go to state 14

state 78

    (16) subroutineDecs -> METHOD type subroutineName LPAREN parameterList RPAREN subroutineBody . subroutineDecs
    (11) subroutineDecs -> . CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (12) subroutineDecs -> . CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (13) subroutineDecs -> . FUNCTION VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (14) subroutineDecs -> . FUNCTION type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (15) subroutineDecs -> . METHOD VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (16) subroutineDecs -> . METHOD type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs
    (17) subroutineDecs -> . empty
    (78) empty -> .

    CONSTRUCTOR     shift and go to state 11
    FUNCTION        shift and go to state 10
    METHOD          shift and go to state 12
    RCURLY          reduce using rule 78 (empty -> .)

    subroutineDecs                 shift and go to state 88
    empty                          shift and go to state 14

state 79

    (22) subroutineBody -> LCURLY varDecs . statements RCURLY
    (30) statements -> . statement statements
    (31) statements -> . empty
    (32) statement -> . letStatement
    (33) statement -> . ifStatement
    (34) statement -> . whileStatement
    (35) statement -> . doStatement
    (36) statement -> . returnStatement
    (78) empty -> .
    (37) letStatement -> . LET varName EQ expression SEMICOLON
    (38) letStatement -> . LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON
    (39) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY
    (40) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (41) whileStatement -> . WHILE LPAREN expression RPAREN LCURLY statements RCURLY
    (42) doStatement -> . DO subroutineCall SEMICOLON
    (43) returnStatement -> . RETURN SEMICOLON
    (44) returnStatement -> . RETURN expression SEMICOLON

    RCURLY          reduce using rule 78 (empty -> .)
    LET             shift and go to state 101
    IF              shift and go to state 99
    WHILE           shift and go to state 91
    DO              shift and go to state 89
    RETURN          shift and go to state 92

    statements                     shift and go to state 90
    doStatement                    shift and go to state 93
    whileStatement                 shift and go to state 97
    letStatement                   shift and go to state 100
    statement                      shift and go to state 94
    returnStatement                shift and go to state 98
    empty                          shift and go to state 96
    ifStatement                    shift and go to state 95

state 80

    (23) varDecs -> VAR . type varName commaVarNames SEMICOLON varDecs
    (7) type -> . INT
    (8) type -> . CHAR
    (9) type -> . BOOLEAN
    (10) type -> . className
    (27) className -> . IDENTIFIER

    INT             shift and go to state 16
    CHAR            shift and go to state 15
    BOOLEAN         shift and go to state 17
    IDENTIFIER      shift and go to state 4

    className                      shift and go to state 18
    type                           shift and go to state 102

state 81

    (24) varDecs -> empty .

    LET             reduce using rule 24 (varDecs -> empty .)
    IF              reduce using rule 24 (varDecs -> empty .)
    WHILE           reduce using rule 24 (varDecs -> empty .)
    DO              reduce using rule 24 (varDecs -> empty .)
    RETURN          reduce using rule 24 (varDecs -> empty .)
    RCURLY          reduce using rule 24 (varDecs -> empty .)


state 82

    (13) subroutineDecs -> FUNCTION VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 13 (subroutineDecs -> FUNCTION VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 83

    (20) additionalParameters -> COMMA type . varName additionalParameters
    (29) varName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 29

    varName                        shift and go to state 103

state 84

    (14) subroutineDecs -> FUNCTION type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 14 (subroutineDecs -> FUNCTION type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 85

    (11) subroutineDecs -> CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 11 (subroutineDecs -> CONSTRUCTOR VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 86

    (12) subroutineDecs -> CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 12 (subroutineDecs -> CONSTRUCTOR type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 87

    (15) subroutineDecs -> METHOD VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 15 (subroutineDecs -> METHOD VOID subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 88

    (16) subroutineDecs -> METHOD type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .

    RCURLY          reduce using rule 16 (subroutineDecs -> METHOD type subroutineName LPAREN parameterList RPAREN subroutineBody subroutineDecs .)


state 89

    (42) doStatement -> DO . subroutineCall SEMICOLON
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER
    (29) varName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 108

    className                      shift and go to state 106
    subroutineCall                 shift and go to state 104
    subroutineName                 shift and go to state 107
    varName                        shift and go to state 105

state 90

    (22) subroutineBody -> LCURLY varDecs statements . RCURLY

    RCURLY          shift and go to state 109


state 91

    (41) whileStatement -> WHILE . LPAREN expression RPAREN LCURLY statements RCURLY

    LPAREN          shift and go to state 110


state 92

    (43) returnStatement -> RETURN . SEMICOLON
    (44) returnStatement -> RETURN . expression SEMICOLON
    (45) expression -> . term opTerms
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    SEMICOLON       shift and go to state 120
    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    subroutineName                 shift and go to state 107
    expression                     shift and go to state 127

state 93

    (35) statement -> doStatement .

    LET             reduce using rule 35 (statement -> doStatement .)
    IF              reduce using rule 35 (statement -> doStatement .)
    WHILE           reduce using rule 35 (statement -> doStatement .)
    DO              reduce using rule 35 (statement -> doStatement .)
    RETURN          reduce using rule 35 (statement -> doStatement .)
    RCURLY          reduce using rule 35 (statement -> doStatement .)


state 94

    (30) statements -> statement . statements
    (30) statements -> . statement statements
    (31) statements -> . empty
    (32) statement -> . letStatement
    (33) statement -> . ifStatement
    (34) statement -> . whileStatement
    (35) statement -> . doStatement
    (36) statement -> . returnStatement
    (78) empty -> .
    (37) letStatement -> . LET varName EQ expression SEMICOLON
    (38) letStatement -> . LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON
    (39) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY
    (40) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (41) whileStatement -> . WHILE LPAREN expression RPAREN LCURLY statements RCURLY
    (42) doStatement -> . DO subroutineCall SEMICOLON
    (43) returnStatement -> . RETURN SEMICOLON
    (44) returnStatement -> . RETURN expression SEMICOLON

    RCURLY          reduce using rule 78 (empty -> .)
    LET             shift and go to state 101
    IF              shift and go to state 99
    WHILE           shift and go to state 91
    DO              shift and go to state 89
    RETURN          shift and go to state 92

    statements                     shift and go to state 128
    doStatement                    shift and go to state 93
    whileStatement                 shift and go to state 97
    letStatement                   shift and go to state 100
    statement                      shift and go to state 94
    returnStatement                shift and go to state 98
    empty                          shift and go to state 96
    ifStatement                    shift and go to state 95

state 95

    (33) statement -> ifStatement .

    LET             reduce using rule 33 (statement -> ifStatement .)
    IF              reduce using rule 33 (statement -> ifStatement .)
    WHILE           reduce using rule 33 (statement -> ifStatement .)
    DO              reduce using rule 33 (statement -> ifStatement .)
    RETURN          reduce using rule 33 (statement -> ifStatement .)
    RCURLY          reduce using rule 33 (statement -> ifStatement .)


state 96

    (31) statements -> empty .

    RCURLY          reduce using rule 31 (statements -> empty .)


state 97

    (34) statement -> whileStatement .

    LET             reduce using rule 34 (statement -> whileStatement .)
    IF              reduce using rule 34 (statement -> whileStatement .)
    WHILE           reduce using rule 34 (statement -> whileStatement .)
    DO              reduce using rule 34 (statement -> whileStatement .)
    RETURN          reduce using rule 34 (statement -> whileStatement .)
    RCURLY          reduce using rule 34 (statement -> whileStatement .)


state 98

    (36) statement -> returnStatement .

    LET             reduce using rule 36 (statement -> returnStatement .)
    IF              reduce using rule 36 (statement -> returnStatement .)
    WHILE           reduce using rule 36 (statement -> returnStatement .)
    DO              reduce using rule 36 (statement -> returnStatement .)
    RETURN          reduce using rule 36 (statement -> returnStatement .)
    RCURLY          reduce using rule 36 (statement -> returnStatement .)


state 99

    (39) ifStatement -> IF . LPAREN expression RPAREN LCURLY statements RCURLY
    (40) ifStatement -> IF . LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY

    LPAREN          shift and go to state 129


state 100

    (32) statement -> letStatement .

    LET             reduce using rule 32 (statement -> letStatement .)
    IF              reduce using rule 32 (statement -> letStatement .)
    WHILE           reduce using rule 32 (statement -> letStatement .)
    DO              reduce using rule 32 (statement -> letStatement .)
    RETURN          reduce using rule 32 (statement -> letStatement .)
    RCURLY          reduce using rule 32 (statement -> letStatement .)


state 101

    (37) letStatement -> LET . varName EQ expression SEMICOLON
    (38) letStatement -> LET . varName LSQUARE expression RSQUARE EQ expression SEMICOLON
    (29) varName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 29

    varName                        shift and go to state 130

state 102

    (23) varDecs -> VAR type . varName commaVarNames SEMICOLON varDecs
    (29) varName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 29

    varName                        shift and go to state 131

state 103

    (20) additionalParameters -> COMMA type varName . additionalParameters
    (20) additionalParameters -> . COMMA type varName additionalParameters
    (21) additionalParameters -> . empty
    (78) empty -> .

    COMMA           shift and go to state 71
    RPAREN          reduce using rule 78 (empty -> .)

    empty                          shift and go to state 72
    additionalParameters           shift and go to state 132

state 104

    (42) doStatement -> DO subroutineCall . SEMICOLON

    SEMICOLON       shift and go to state 133


state 105

    (58) subroutineCall -> varName . DOT subroutineName LPAREN expressionList RPAREN

    DOT             shift and go to state 134


state 106

    (57) subroutineCall -> className . DOT subroutineName LPAREN expressionList RPAREN

    DOT             shift and go to state 135


state 107

    (56) subroutineCall -> subroutineName . LPAREN expressionList RPAREN

    LPAREN          shift and go to state 136


state 108

    (28) subroutineName -> IDENTIFIER .
    (27) className -> IDENTIFIER .
    (29) varName -> IDENTIFIER .

  ! reduce/reduce conflict for DOT resolved using rule 27 (className -> IDENTIFIER .)
    LPAREN          reduce using rule 28 (subroutineName -> IDENTIFIER .)
    DOT             reduce using rule 27 (className -> IDENTIFIER .)

  ! DOT             [ reduce using rule 29 (varName -> IDENTIFIER .) ]


state 109

    (22) subroutineBody -> LCURLY varDecs statements RCURLY .

    CONSTRUCTOR     reduce using rule 22 (subroutineBody -> LCURLY varDecs statements RCURLY .)
    FUNCTION        reduce using rule 22 (subroutineBody -> LCURLY varDecs statements RCURLY .)
    METHOD          reduce using rule 22 (subroutineBody -> LCURLY varDecs statements RCURLY .)
    RCURLY          reduce using rule 22 (subroutineBody -> LCURLY varDecs statements RCURLY .)


state 110

    (41) whileStatement -> WHILE LPAREN . expression RPAREN LCURLY statements RCURLY
    (45) expression -> . term opTerms
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    subroutineName                 shift and go to state 107
    subroutineCall                 shift and go to state 119
    expression                     shift and go to state 137

state 111

    (49) term -> LPAREN . expression RPAREN
    (45) expression -> . term opTerms
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    subroutineName                 shift and go to state 107
    expression                     shift and go to state 138

state 112

    (52) term -> varName .
    (55) term -> varName . LSQUARE expression RSQUARE
    (58) subroutineCall -> varName . DOT subroutineName LPAREN expressionList RPAREN

    PLUS            reduce using rule 52 (term -> varName .)
    MINUS           reduce using rule 52 (term -> varName .)
    TIMES           reduce using rule 52 (term -> varName .)
    DIVIDE          reduce using rule 52 (term -> varName .)
    AMP             reduce using rule 52 (term -> varName .)
    PIPE            reduce using rule 52 (term -> varName .)
    LT              reduce using rule 52 (term -> varName .)
    GT              reduce using rule 52 (term -> varName .)
    EQ              reduce using rule 52 (term -> varName .)
    RPAREN          reduce using rule 52 (term -> varName .)
    COMMA           reduce using rule 52 (term -> varName .)
    RSQUARE         reduce using rule 52 (term -> varName .)
    SEMICOLON       reduce using rule 52 (term -> varName .)
    LSQUARE         shift and go to state 139
    DOT             shift and go to state 134


state 113

    (53) term -> keywordConstant .

    PLUS            reduce using rule 53 (term -> keywordConstant .)
    MINUS           reduce using rule 53 (term -> keywordConstant .)
    TIMES           reduce using rule 53 (term -> keywordConstant .)
    DIVIDE          reduce using rule 53 (term -> keywordConstant .)
    AMP             reduce using rule 53 (term -> keywordConstant .)
    PIPE            reduce using rule 53 (term -> keywordConstant .)
    LT              reduce using rule 53 (term -> keywordConstant .)
    GT              reduce using rule 53 (term -> keywordConstant .)
    EQ              reduce using rule 53 (term -> keywordConstant .)
    RPAREN          reduce using rule 53 (term -> keywordConstant .)
    COMMA           reduce using rule 53 (term -> keywordConstant .)
    RSQUARE         reduce using rule 53 (term -> keywordConstant .)
    SEMICOLON       reduce using rule 53 (term -> keywordConstant .)


state 114

    (76) keywordConstant -> NULL .

    PLUS            reduce using rule 76 (keywordConstant -> NULL .)
    MINUS           reduce using rule 76 (keywordConstant -> NULL .)
    TIMES           reduce using rule 76 (keywordConstant -> NULL .)
    DIVIDE          reduce using rule 76 (keywordConstant -> NULL .)
    AMP             reduce using rule 76 (keywordConstant -> NULL .)
    PIPE            reduce using rule 76 (keywordConstant -> NULL .)
    LT              reduce using rule 76 (keywordConstant -> NULL .)
    GT              reduce using rule 76 (keywordConstant -> NULL .)
    EQ              reduce using rule 76 (keywordConstant -> NULL .)
    COMMA           reduce using rule 76 (keywordConstant -> NULL .)
    RPAREN          reduce using rule 76 (keywordConstant -> NULL .)
    SEMICOLON       reduce using rule 76 (keywordConstant -> NULL .)
    RSQUARE         reduce using rule 76 (keywordConstant -> NULL .)


state 115

    (74) keywordConstant -> TRUE .

    PLUS            reduce using rule 74 (keywordConstant -> TRUE .)
    MINUS           reduce using rule 74 (keywordConstant -> TRUE .)
    TIMES           reduce using rule 74 (keywordConstant -> TRUE .)
    DIVIDE          reduce using rule 74 (keywordConstant -> TRUE .)
    AMP             reduce using rule 74 (keywordConstant -> TRUE .)
    PIPE            reduce using rule 74 (keywordConstant -> TRUE .)
    LT              reduce using rule 74 (keywordConstant -> TRUE .)
    GT              reduce using rule 74 (keywordConstant -> TRUE .)
    EQ              reduce using rule 74 (keywordConstant -> TRUE .)
    COMMA           reduce using rule 74 (keywordConstant -> TRUE .)
    RPAREN          reduce using rule 74 (keywordConstant -> TRUE .)
    SEMICOLON       reduce using rule 74 (keywordConstant -> TRUE .)
    RSQUARE         reduce using rule 74 (keywordConstant -> TRUE .)


state 116

    (72) unaryOp -> MINUS .

    INT_CONST       reduce using rule 72 (unaryOp -> MINUS .)
    LPAREN          reduce using rule 72 (unaryOp -> MINUS .)
    STRING_CONST    reduce using rule 72 (unaryOp -> MINUS .)
    MINUS           reduce using rule 72 (unaryOp -> MINUS .)
    TILDE           reduce using rule 72 (unaryOp -> MINUS .)
    IDENTIFIER      reduce using rule 72 (unaryOp -> MINUS .)
    TRUE            reduce using rule 72 (unaryOp -> MINUS .)
    FALSE           reduce using rule 72 (unaryOp -> MINUS .)
    NULL            reduce using rule 72 (unaryOp -> MINUS .)
    THIS            reduce using rule 72 (unaryOp -> MINUS .)


state 117

    (54) term -> STRING_CONST .

    PLUS            reduce using rule 54 (term -> STRING_CONST .)
    MINUS           reduce using rule 54 (term -> STRING_CONST .)
    TIMES           reduce using rule 54 (term -> STRING_CONST .)
    DIVIDE          reduce using rule 54 (term -> STRING_CONST .)
    AMP             reduce using rule 54 (term -> STRING_CONST .)
    PIPE            reduce using rule 54 (term -> STRING_CONST .)
    LT              reduce using rule 54 (term -> STRING_CONST .)
    GT              reduce using rule 54 (term -> STRING_CONST .)
    EQ              reduce using rule 54 (term -> STRING_CONST .)
    RPAREN          reduce using rule 54 (term -> STRING_CONST .)
    COMMA           reduce using rule 54 (term -> STRING_CONST .)
    RSQUARE         reduce using rule 54 (term -> STRING_CONST .)
    SEMICOLON       reduce using rule 54 (term -> STRING_CONST .)


state 118

    (48) term -> INT_CONST .

    PLUS            reduce using rule 48 (term -> INT_CONST .)
    MINUS           reduce using rule 48 (term -> INT_CONST .)
    TIMES           reduce using rule 48 (term -> INT_CONST .)
    DIVIDE          reduce using rule 48 (term -> INT_CONST .)
    AMP             reduce using rule 48 (term -> INT_CONST .)
    PIPE            reduce using rule 48 (term -> INT_CONST .)
    LT              reduce using rule 48 (term -> INT_CONST .)
    GT              reduce using rule 48 (term -> INT_CONST .)
    EQ              reduce using rule 48 (term -> INT_CONST .)
    RPAREN          reduce using rule 48 (term -> INT_CONST .)
    COMMA           reduce using rule 48 (term -> INT_CONST .)
    RSQUARE         reduce using rule 48 (term -> INT_CONST .)
    SEMICOLON       reduce using rule 48 (term -> INT_CONST .)


state 119

    (51) term -> subroutineCall .

    PLUS            reduce using rule 51 (term -> subroutineCall .)
    MINUS           reduce using rule 51 (term -> subroutineCall .)
    TIMES           reduce using rule 51 (term -> subroutineCall .)
    DIVIDE          reduce using rule 51 (term -> subroutineCall .)
    AMP             reduce using rule 51 (term -> subroutineCall .)
    PIPE            reduce using rule 51 (term -> subroutineCall .)
    LT              reduce using rule 51 (term -> subroutineCall .)
    GT              reduce using rule 51 (term -> subroutineCall .)
    EQ              reduce using rule 51 (term -> subroutineCall .)
    RPAREN          reduce using rule 51 (term -> subroutineCall .)
    COMMA           reduce using rule 51 (term -> subroutineCall .)
    RSQUARE         reduce using rule 51 (term -> subroutineCall .)
    SEMICOLON       reduce using rule 51 (term -> subroutineCall .)


state 120

    (43) returnStatement -> RETURN SEMICOLON .

    LET             reduce using rule 43 (returnStatement -> RETURN SEMICOLON .)
    IF              reduce using rule 43 (returnStatement -> RETURN SEMICOLON .)
    WHILE           reduce using rule 43 (returnStatement -> RETURN SEMICOLON .)
    DO              reduce using rule 43 (returnStatement -> RETURN SEMICOLON .)
    RETURN          reduce using rule 43 (returnStatement -> RETURN SEMICOLON .)
    RCURLY          reduce using rule 43 (returnStatement -> RETURN SEMICOLON .)


state 121

    (73) unaryOp -> TILDE .

    INT_CONST       reduce using rule 73 (unaryOp -> TILDE .)
    LPAREN          reduce using rule 73 (unaryOp -> TILDE .)
    STRING_CONST    reduce using rule 73 (unaryOp -> TILDE .)
    MINUS           reduce using rule 73 (unaryOp -> TILDE .)
    TILDE           reduce using rule 73 (unaryOp -> TILDE .)
    IDENTIFIER      reduce using rule 73 (unaryOp -> TILDE .)
    TRUE            reduce using rule 73 (unaryOp -> TILDE .)
    FALSE           reduce using rule 73 (unaryOp -> TILDE .)
    NULL            reduce using rule 73 (unaryOp -> TILDE .)
    THIS            reduce using rule 73 (unaryOp -> TILDE .)


state 122

    (29) varName -> IDENTIFIER .
    (28) subroutineName -> IDENTIFIER .
    (27) className -> IDENTIFIER .

  ! reduce/reduce conflict for DOT resolved using rule 27 (className -> IDENTIFIER .)
    LSQUARE         reduce using rule 29 (varName -> IDENTIFIER .)
    PLUS            reduce using rule 29 (varName -> IDENTIFIER .)
    MINUS           reduce using rule 29 (varName -> IDENTIFIER .)
    TIMES           reduce using rule 29 (varName -> IDENTIFIER .)
    DIVIDE          reduce using rule 29 (varName -> IDENTIFIER .)
    AMP             reduce using rule 29 (varName -> IDENTIFIER .)
    PIPE            reduce using rule 29 (varName -> IDENTIFIER .)
    LT              reduce using rule 29 (varName -> IDENTIFIER .)
    GT              reduce using rule 29 (varName -> IDENTIFIER .)
    EQ              reduce using rule 29 (varName -> IDENTIFIER .)
    SEMICOLON       reduce using rule 29 (varName -> IDENTIFIER .)
    RSQUARE         reduce using rule 29 (varName -> IDENTIFIER .)
    RPAREN          reduce using rule 29 (varName -> IDENTIFIER .)
    COMMA           reduce using rule 29 (varName -> IDENTIFIER .)
    LPAREN          reduce using rule 28 (subroutineName -> IDENTIFIER .)
    DOT             reduce using rule 27 (className -> IDENTIFIER .)

  ! DOT             [ reduce using rule 29 (varName -> IDENTIFIER .) ]


state 123

    (45) expression -> term . opTerms
    (46) opTerms -> . op term opTerms
    (47) opTerms -> . empty
    (63) op -> . PLUS
    (64) op -> . MINUS
    (65) op -> . TIMES
    (66) op -> . DIVIDE
    (67) op -> . AMP
    (68) op -> . PIPE
    (69) op -> . LT
    (70) op -> . GT
    (71) op -> . EQ
    (78) empty -> .

    PLUS            shift and go to state 145
    MINUS           shift and go to state 149
    TIMES           shift and go to state 142
    DIVIDE          shift and go to state 141
    AMP             shift and go to state 146
    PIPE            shift and go to state 143
    LT              shift and go to state 144
    GT              shift and go to state 140
    EQ              shift and go to state 148
    SEMICOLON       reduce using rule 78 (empty -> .)
    RPAREN          reduce using rule 78 (empty -> .)
    COMMA           reduce using rule 78 (empty -> .)
    RSQUARE         reduce using rule 78 (empty -> .)

    opTerms                        shift and go to state 147
    empty                          shift and go to state 150
    op                             shift and go to state 151

state 124

    (75) keywordConstant -> FALSE .

    PLUS            reduce using rule 75 (keywordConstant -> FALSE .)
    MINUS           reduce using rule 75 (keywordConstant -> FALSE .)
    TIMES           reduce using rule 75 (keywordConstant -> FALSE .)
    DIVIDE          reduce using rule 75 (keywordConstant -> FALSE .)
    AMP             reduce using rule 75 (keywordConstant -> FALSE .)
    PIPE            reduce using rule 75 (keywordConstant -> FALSE .)
    LT              reduce using rule 75 (keywordConstant -> FALSE .)
    GT              reduce using rule 75 (keywordConstant -> FALSE .)
    EQ              reduce using rule 75 (keywordConstant -> FALSE .)
    COMMA           reduce using rule 75 (keywordConstant -> FALSE .)
    RPAREN          reduce using rule 75 (keywordConstant -> FALSE .)
    SEMICOLON       reduce using rule 75 (keywordConstant -> FALSE .)
    RSQUARE         reduce using rule 75 (keywordConstant -> FALSE .)


state 125

    (50) term -> unaryOp . term
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 152
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    subroutineName                 shift and go to state 107

state 126

    (77) keywordConstant -> THIS .

    PLUS            reduce using rule 77 (keywordConstant -> THIS .)
    MINUS           reduce using rule 77 (keywordConstant -> THIS .)
    TIMES           reduce using rule 77 (keywordConstant -> THIS .)
    DIVIDE          reduce using rule 77 (keywordConstant -> THIS .)
    AMP             reduce using rule 77 (keywordConstant -> THIS .)
    PIPE            reduce using rule 77 (keywordConstant -> THIS .)
    LT              reduce using rule 77 (keywordConstant -> THIS .)
    GT              reduce using rule 77 (keywordConstant -> THIS .)
    EQ              reduce using rule 77 (keywordConstant -> THIS .)
    COMMA           reduce using rule 77 (keywordConstant -> THIS .)
    RPAREN          reduce using rule 77 (keywordConstant -> THIS .)
    SEMICOLON       reduce using rule 77 (keywordConstant -> THIS .)
    RSQUARE         reduce using rule 77 (keywordConstant -> THIS .)


state 127

    (44) returnStatement -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 153


state 128

    (30) statements -> statement statements .

    RCURLY          reduce using rule 30 (statements -> statement statements .)


state 129

    (39) ifStatement -> IF LPAREN . expression RPAREN LCURLY statements RCURLY
    (40) ifStatement -> IF LPAREN . expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (45) expression -> . term opTerms
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    subroutineName                 shift and go to state 107
    subroutineCall                 shift and go to state 119
    expression                     shift and go to state 154

state 130

    (37) letStatement -> LET varName . EQ expression SEMICOLON
    (38) letStatement -> LET varName . LSQUARE expression RSQUARE EQ expression SEMICOLON

    EQ              shift and go to state 155
    LSQUARE         shift and go to state 156


state 131

    (23) varDecs -> VAR type varName . commaVarNames SEMICOLON varDecs
    (25) commaVarNames -> . COMMA varName commaVarNames
    (26) commaVarNames -> . empty
    (78) empty -> .

    COMMA           shift and go to state 157
    SEMICOLON       reduce using rule 78 (empty -> .)

    commaVarNames                  shift and go to state 158
    empty                          shift and go to state 159

state 132

    (20) additionalParameters -> COMMA type varName additionalParameters .

    RPAREN          reduce using rule 20 (additionalParameters -> COMMA type varName additionalParameters .)


state 133

    (42) doStatement -> DO subroutineCall SEMICOLON .

    LET             reduce using rule 42 (doStatement -> DO subroutineCall SEMICOLON .)
    IF              reduce using rule 42 (doStatement -> DO subroutineCall SEMICOLON .)
    WHILE           reduce using rule 42 (doStatement -> DO subroutineCall SEMICOLON .)
    DO              reduce using rule 42 (doStatement -> DO subroutineCall SEMICOLON .)
    RETURN          reduce using rule 42 (doStatement -> DO subroutineCall SEMICOLON .)
    RCURLY          reduce using rule 42 (doStatement -> DO subroutineCall SEMICOLON .)


state 134

    (58) subroutineCall -> varName DOT . subroutineName LPAREN expressionList RPAREN
    (28) subroutineName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 32

    subroutineName                 shift and go to state 160

state 135

    (57) subroutineCall -> className DOT . subroutineName LPAREN expressionList RPAREN
    (28) subroutineName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 32

    subroutineName                 shift and go to state 161

state 136

    (56) subroutineCall -> subroutineName LPAREN . expressionList RPAREN
    (59) expressionList -> . expression commaExpressions
    (60) expressionList -> . empty
    (45) expression -> . term opTerms
    (78) empty -> .
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    RPAREN          reduce using rule 78 (empty -> .)
    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    expressionList                 shift and go to state 162
    subroutineName                 shift and go to state 107
    expression                     shift and go to state 164
    empty                          shift and go to state 163

state 137

    (41) whileStatement -> WHILE LPAREN expression . RPAREN LCURLY statements RCURLY

    RPAREN          shift and go to state 165


state 138

    (49) term -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 166


state 139

    (55) term -> varName LSQUARE . expression RSQUARE
    (45) expression -> . term opTerms
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    subroutineName                 shift and go to state 107
    expression                     shift and go to state 167

state 140

    (70) op -> GT .

    INT_CONST       reduce using rule 70 (op -> GT .)
    LPAREN          reduce using rule 70 (op -> GT .)
    STRING_CONST    reduce using rule 70 (op -> GT .)
    MINUS           reduce using rule 70 (op -> GT .)
    TILDE           reduce using rule 70 (op -> GT .)
    IDENTIFIER      reduce using rule 70 (op -> GT .)
    TRUE            reduce using rule 70 (op -> GT .)
    FALSE           reduce using rule 70 (op -> GT .)
    NULL            reduce using rule 70 (op -> GT .)
    THIS            reduce using rule 70 (op -> GT .)


state 141

    (66) op -> DIVIDE .

    INT_CONST       reduce using rule 66 (op -> DIVIDE .)
    LPAREN          reduce using rule 66 (op -> DIVIDE .)
    STRING_CONST    reduce using rule 66 (op -> DIVIDE .)
    MINUS           reduce using rule 66 (op -> DIVIDE .)
    TILDE           reduce using rule 66 (op -> DIVIDE .)
    IDENTIFIER      reduce using rule 66 (op -> DIVIDE .)
    TRUE            reduce using rule 66 (op -> DIVIDE .)
    FALSE           reduce using rule 66 (op -> DIVIDE .)
    NULL            reduce using rule 66 (op -> DIVIDE .)
    THIS            reduce using rule 66 (op -> DIVIDE .)


state 142

    (65) op -> TIMES .

    INT_CONST       reduce using rule 65 (op -> TIMES .)
    LPAREN          reduce using rule 65 (op -> TIMES .)
    STRING_CONST    reduce using rule 65 (op -> TIMES .)
    MINUS           reduce using rule 65 (op -> TIMES .)
    TILDE           reduce using rule 65 (op -> TIMES .)
    IDENTIFIER      reduce using rule 65 (op -> TIMES .)
    TRUE            reduce using rule 65 (op -> TIMES .)
    FALSE           reduce using rule 65 (op -> TIMES .)
    NULL            reduce using rule 65 (op -> TIMES .)
    THIS            reduce using rule 65 (op -> TIMES .)


state 143

    (68) op -> PIPE .

    INT_CONST       reduce using rule 68 (op -> PIPE .)
    LPAREN          reduce using rule 68 (op -> PIPE .)
    STRING_CONST    reduce using rule 68 (op -> PIPE .)
    MINUS           reduce using rule 68 (op -> PIPE .)
    TILDE           reduce using rule 68 (op -> PIPE .)
    IDENTIFIER      reduce using rule 68 (op -> PIPE .)
    TRUE            reduce using rule 68 (op -> PIPE .)
    FALSE           reduce using rule 68 (op -> PIPE .)
    NULL            reduce using rule 68 (op -> PIPE .)
    THIS            reduce using rule 68 (op -> PIPE .)


state 144

    (69) op -> LT .

    INT_CONST       reduce using rule 69 (op -> LT .)
    LPAREN          reduce using rule 69 (op -> LT .)
    STRING_CONST    reduce using rule 69 (op -> LT .)
    MINUS           reduce using rule 69 (op -> LT .)
    TILDE           reduce using rule 69 (op -> LT .)
    IDENTIFIER      reduce using rule 69 (op -> LT .)
    TRUE            reduce using rule 69 (op -> LT .)
    FALSE           reduce using rule 69 (op -> LT .)
    NULL            reduce using rule 69 (op -> LT .)
    THIS            reduce using rule 69 (op -> LT .)


state 145

    (63) op -> PLUS .

    INT_CONST       reduce using rule 63 (op -> PLUS .)
    LPAREN          reduce using rule 63 (op -> PLUS .)
    STRING_CONST    reduce using rule 63 (op -> PLUS .)
    MINUS           reduce using rule 63 (op -> PLUS .)
    TILDE           reduce using rule 63 (op -> PLUS .)
    IDENTIFIER      reduce using rule 63 (op -> PLUS .)
    TRUE            reduce using rule 63 (op -> PLUS .)
    FALSE           reduce using rule 63 (op -> PLUS .)
    NULL            reduce using rule 63 (op -> PLUS .)
    THIS            reduce using rule 63 (op -> PLUS .)


state 146

    (67) op -> AMP .

    INT_CONST       reduce using rule 67 (op -> AMP .)
    LPAREN          reduce using rule 67 (op -> AMP .)
    STRING_CONST    reduce using rule 67 (op -> AMP .)
    MINUS           reduce using rule 67 (op -> AMP .)
    TILDE           reduce using rule 67 (op -> AMP .)
    IDENTIFIER      reduce using rule 67 (op -> AMP .)
    TRUE            reduce using rule 67 (op -> AMP .)
    FALSE           reduce using rule 67 (op -> AMP .)
    NULL            reduce using rule 67 (op -> AMP .)
    THIS            reduce using rule 67 (op -> AMP .)


state 147

    (45) expression -> term opTerms .

    RPAREN          reduce using rule 45 (expression -> term opTerms .)
    RSQUARE         reduce using rule 45 (expression -> term opTerms .)
    SEMICOLON       reduce using rule 45 (expression -> term opTerms .)
    COMMA           reduce using rule 45 (expression -> term opTerms .)


state 148

    (71) op -> EQ .

    INT_CONST       reduce using rule 71 (op -> EQ .)
    LPAREN          reduce using rule 71 (op -> EQ .)
    STRING_CONST    reduce using rule 71 (op -> EQ .)
    MINUS           reduce using rule 71 (op -> EQ .)
    TILDE           reduce using rule 71 (op -> EQ .)
    IDENTIFIER      reduce using rule 71 (op -> EQ .)
    TRUE            reduce using rule 71 (op -> EQ .)
    FALSE           reduce using rule 71 (op -> EQ .)
    NULL            reduce using rule 71 (op -> EQ .)
    THIS            reduce using rule 71 (op -> EQ .)


state 149

    (64) op -> MINUS .

    INT_CONST       reduce using rule 64 (op -> MINUS .)
    LPAREN          reduce using rule 64 (op -> MINUS .)
    STRING_CONST    reduce using rule 64 (op -> MINUS .)
    MINUS           reduce using rule 64 (op -> MINUS .)
    TILDE           reduce using rule 64 (op -> MINUS .)
    IDENTIFIER      reduce using rule 64 (op -> MINUS .)
    TRUE            reduce using rule 64 (op -> MINUS .)
    FALSE           reduce using rule 64 (op -> MINUS .)
    NULL            reduce using rule 64 (op -> MINUS .)
    THIS            reduce using rule 64 (op -> MINUS .)


state 150

    (47) opTerms -> empty .

    SEMICOLON       reduce using rule 47 (opTerms -> empty .)
    RPAREN          reduce using rule 47 (opTerms -> empty .)
    COMMA           reduce using rule 47 (opTerms -> empty .)
    RSQUARE         reduce using rule 47 (opTerms -> empty .)


state 151

    (46) opTerms -> op . term opTerms
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 168
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    subroutineName                 shift and go to state 107

state 152

    (50) term -> unaryOp term .

    PLUS            reduce using rule 50 (term -> unaryOp term .)
    MINUS           reduce using rule 50 (term -> unaryOp term .)
    TIMES           reduce using rule 50 (term -> unaryOp term .)
    DIVIDE          reduce using rule 50 (term -> unaryOp term .)
    AMP             reduce using rule 50 (term -> unaryOp term .)
    PIPE            reduce using rule 50 (term -> unaryOp term .)
    LT              reduce using rule 50 (term -> unaryOp term .)
    GT              reduce using rule 50 (term -> unaryOp term .)
    EQ              reduce using rule 50 (term -> unaryOp term .)
    RPAREN          reduce using rule 50 (term -> unaryOp term .)
    COMMA           reduce using rule 50 (term -> unaryOp term .)
    RSQUARE         reduce using rule 50 (term -> unaryOp term .)
    SEMICOLON       reduce using rule 50 (term -> unaryOp term .)


state 153

    (44) returnStatement -> RETURN expression SEMICOLON .

    LET             reduce using rule 44 (returnStatement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 44 (returnStatement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 44 (returnStatement -> RETURN expression SEMICOLON .)
    DO              reduce using rule 44 (returnStatement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 44 (returnStatement -> RETURN expression SEMICOLON .)
    RCURLY          reduce using rule 44 (returnStatement -> RETURN expression SEMICOLON .)


state 154

    (39) ifStatement -> IF LPAREN expression . RPAREN LCURLY statements RCURLY
    (40) ifStatement -> IF LPAREN expression . RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY

    RPAREN          shift and go to state 169


state 155

    (37) letStatement -> LET varName EQ . expression SEMICOLON
    (45) expression -> . term opTerms
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    subroutineName                 shift and go to state 107
    expression                     shift and go to state 170

state 156

    (38) letStatement -> LET varName LSQUARE . expression RSQUARE EQ expression SEMICOLON
    (45) expression -> . term opTerms
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    subroutineName                 shift and go to state 107
    expression                     shift and go to state 171

state 157

    (25) commaVarNames -> COMMA . varName commaVarNames
    (29) varName -> . IDENTIFIER

    IDENTIFIER      shift and go to state 29

    varName                        shift and go to state 172

state 158

    (23) varDecs -> VAR type varName commaVarNames . SEMICOLON varDecs

    SEMICOLON       shift and go to state 173


state 159

    (26) commaVarNames -> empty .

    SEMICOLON       reduce using rule 26 (commaVarNames -> empty .)


state 160

    (58) subroutineCall -> varName DOT subroutineName . LPAREN expressionList RPAREN

    LPAREN          shift and go to state 174


state 161

    (57) subroutineCall -> className DOT subroutineName . LPAREN expressionList RPAREN

    LPAREN          shift and go to state 175


state 162

    (56) subroutineCall -> subroutineName LPAREN expressionList . RPAREN

    RPAREN          shift and go to state 176


state 163

    (60) expressionList -> empty .

    RPAREN          reduce using rule 60 (expressionList -> empty .)


state 164

    (59) expressionList -> expression . commaExpressions
    (61) commaExpressions -> . COMMA expression commaExpressions
    (62) commaExpressions -> . empty
    (78) empty -> .

    COMMA           shift and go to state 177
    RPAREN          reduce using rule 78 (empty -> .)

    empty                          shift and go to state 178
    commaExpressions               shift and go to state 179

state 165

    (41) whileStatement -> WHILE LPAREN expression RPAREN . LCURLY statements RCURLY

    LCURLY          shift and go to state 180


state 166

    (49) term -> LPAREN expression RPAREN .

    PLUS            reduce using rule 49 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 49 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 49 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 49 (term -> LPAREN expression RPAREN .)
    AMP             reduce using rule 49 (term -> LPAREN expression RPAREN .)
    PIPE            reduce using rule 49 (term -> LPAREN expression RPAREN .)
    LT              reduce using rule 49 (term -> LPAREN expression RPAREN .)
    GT              reduce using rule 49 (term -> LPAREN expression RPAREN .)
    EQ              reduce using rule 49 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 49 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 49 (term -> LPAREN expression RPAREN .)
    RSQUARE         reduce using rule 49 (term -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 49 (term -> LPAREN expression RPAREN .)


state 167

    (55) term -> varName LSQUARE expression . RSQUARE

    RSQUARE         shift and go to state 181


state 168

    (46) opTerms -> op term . opTerms
    (46) opTerms -> . op term opTerms
    (47) opTerms -> . empty
    (63) op -> . PLUS
    (64) op -> . MINUS
    (65) op -> . TIMES
    (66) op -> . DIVIDE
    (67) op -> . AMP
    (68) op -> . PIPE
    (69) op -> . LT
    (70) op -> . GT
    (71) op -> . EQ
    (78) empty -> .

    PLUS            shift and go to state 145
    MINUS           shift and go to state 149
    TIMES           shift and go to state 142
    DIVIDE          shift and go to state 141
    AMP             shift and go to state 146
    PIPE            shift and go to state 143
    LT              shift and go to state 144
    GT              shift and go to state 140
    EQ              shift and go to state 148
    SEMICOLON       reduce using rule 78 (empty -> .)
    RPAREN          reduce using rule 78 (empty -> .)
    COMMA           reduce using rule 78 (empty -> .)
    RSQUARE         reduce using rule 78 (empty -> .)

    opTerms                        shift and go to state 182
    empty                          shift and go to state 150
    op                             shift and go to state 151

state 169

    (39) ifStatement -> IF LPAREN expression RPAREN . LCURLY statements RCURLY
    (40) ifStatement -> IF LPAREN expression RPAREN . LCURLY statements RCURLY ELSE LCURLY statements RCURLY

    LCURLY          shift and go to state 183


state 170

    (37) letStatement -> LET varName EQ expression . SEMICOLON

    SEMICOLON       shift and go to state 184


state 171

    (38) letStatement -> LET varName LSQUARE expression . RSQUARE EQ expression SEMICOLON

    RSQUARE         shift and go to state 185


state 172

    (25) commaVarNames -> COMMA varName . commaVarNames
    (25) commaVarNames -> . COMMA varName commaVarNames
    (26) commaVarNames -> . empty
    (78) empty -> .

    COMMA           shift and go to state 157
    SEMICOLON       reduce using rule 78 (empty -> .)

    commaVarNames                  shift and go to state 186
    empty                          shift and go to state 159

state 173

    (23) varDecs -> VAR type varName commaVarNames SEMICOLON . varDecs
    (23) varDecs -> . VAR type varName commaVarNames SEMICOLON varDecs
    (24) varDecs -> . empty
    (78) empty -> .

    VAR             shift and go to state 80
    LET             reduce using rule 78 (empty -> .)
    IF              reduce using rule 78 (empty -> .)
    WHILE           reduce using rule 78 (empty -> .)
    DO              reduce using rule 78 (empty -> .)
    RETURN          reduce using rule 78 (empty -> .)
    RCURLY          reduce using rule 78 (empty -> .)

    varDecs                        shift and go to state 187
    empty                          shift and go to state 81

state 174

    (58) subroutineCall -> varName DOT subroutineName LPAREN . expressionList RPAREN
    (59) expressionList -> . expression commaExpressions
    (60) expressionList -> . empty
    (45) expression -> . term opTerms
    (78) empty -> .
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    RPAREN          reduce using rule 78 (empty -> .)
    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    expressionList                 shift and go to state 188
    subroutineName                 shift and go to state 107
    expression                     shift and go to state 164
    empty                          shift and go to state 163

state 175

    (57) subroutineCall -> className DOT subroutineName LPAREN . expressionList RPAREN
    (59) expressionList -> . expression commaExpressions
    (60) expressionList -> . empty
    (45) expression -> . term opTerms
    (78) empty -> .
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    RPAREN          reduce using rule 78 (empty -> .)
    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    expressionList                 shift and go to state 189
    subroutineName                 shift and go to state 107
    expression                     shift and go to state 164
    empty                          shift and go to state 163

state 176

    (56) subroutineCall -> subroutineName LPAREN expressionList RPAREN .

    PLUS            reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    MINUS           reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    TIMES           reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    DIVIDE          reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    AMP             reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    PIPE            reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    LT              reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    GT              reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    EQ              reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    SEMICOLON       reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    RPAREN          reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    COMMA           reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)
    RSQUARE         reduce using rule 56 (subroutineCall -> subroutineName LPAREN expressionList RPAREN .)


state 177

    (61) commaExpressions -> COMMA . expression commaExpressions
    (45) expression -> . term opTerms
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    subroutineName                 shift and go to state 107
    expression                     shift and go to state 190

state 178

    (62) commaExpressions -> empty .

    RPAREN          reduce using rule 62 (commaExpressions -> empty .)


state 179

    (59) expressionList -> expression commaExpressions .

    RPAREN          reduce using rule 59 (expressionList -> expression commaExpressions .)


state 180

    (41) whileStatement -> WHILE LPAREN expression RPAREN LCURLY . statements RCURLY
    (30) statements -> . statement statements
    (31) statements -> . empty
    (32) statement -> . letStatement
    (33) statement -> . ifStatement
    (34) statement -> . whileStatement
    (35) statement -> . doStatement
    (36) statement -> . returnStatement
    (78) empty -> .
    (37) letStatement -> . LET varName EQ expression SEMICOLON
    (38) letStatement -> . LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON
    (39) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY
    (40) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (41) whileStatement -> . WHILE LPAREN expression RPAREN LCURLY statements RCURLY
    (42) doStatement -> . DO subroutineCall SEMICOLON
    (43) returnStatement -> . RETURN SEMICOLON
    (44) returnStatement -> . RETURN expression SEMICOLON

    RCURLY          reduce using rule 78 (empty -> .)
    LET             shift and go to state 101
    IF              shift and go to state 99
    WHILE           shift and go to state 91
    DO              shift and go to state 89
    RETURN          shift and go to state 92

    statements                     shift and go to state 191
    doStatement                    shift and go to state 93
    whileStatement                 shift and go to state 97
    letStatement                   shift and go to state 100
    statement                      shift and go to state 94
    returnStatement                shift and go to state 98
    empty                          shift and go to state 96
    ifStatement                    shift and go to state 95

state 181

    (55) term -> varName LSQUARE expression RSQUARE .

    PLUS            reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    MINUS           reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    TIMES           reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    DIVIDE          reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    AMP             reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    PIPE            reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    LT              reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    GT              reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    EQ              reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    RPAREN          reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    COMMA           reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    RSQUARE         reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)
    SEMICOLON       reduce using rule 55 (term -> varName LSQUARE expression RSQUARE .)


state 182

    (46) opTerms -> op term opTerms .

    SEMICOLON       reduce using rule 46 (opTerms -> op term opTerms .)
    RPAREN          reduce using rule 46 (opTerms -> op term opTerms .)
    COMMA           reduce using rule 46 (opTerms -> op term opTerms .)
    RSQUARE         reduce using rule 46 (opTerms -> op term opTerms .)


state 183

    (39) ifStatement -> IF LPAREN expression RPAREN LCURLY . statements RCURLY
    (40) ifStatement -> IF LPAREN expression RPAREN LCURLY . statements RCURLY ELSE LCURLY statements RCURLY
    (30) statements -> . statement statements
    (31) statements -> . empty
    (32) statement -> . letStatement
    (33) statement -> . ifStatement
    (34) statement -> . whileStatement
    (35) statement -> . doStatement
    (36) statement -> . returnStatement
    (78) empty -> .
    (37) letStatement -> . LET varName EQ expression SEMICOLON
    (38) letStatement -> . LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON
    (39) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY
    (40) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (41) whileStatement -> . WHILE LPAREN expression RPAREN LCURLY statements RCURLY
    (42) doStatement -> . DO subroutineCall SEMICOLON
    (43) returnStatement -> . RETURN SEMICOLON
    (44) returnStatement -> . RETURN expression SEMICOLON

    RCURLY          reduce using rule 78 (empty -> .)
    LET             shift and go to state 101
    IF              shift and go to state 99
    WHILE           shift and go to state 91
    DO              shift and go to state 89
    RETURN          shift and go to state 92

    statements                     shift and go to state 192
    doStatement                    shift and go to state 93
    whileStatement                 shift and go to state 97
    letStatement                   shift and go to state 100
    statement                      shift and go to state 94
    returnStatement                shift and go to state 98
    empty                          shift and go to state 96
    ifStatement                    shift and go to state 95

state 184

    (37) letStatement -> LET varName EQ expression SEMICOLON .

    LET             reduce using rule 37 (letStatement -> LET varName EQ expression SEMICOLON .)
    IF              reduce using rule 37 (letStatement -> LET varName EQ expression SEMICOLON .)
    WHILE           reduce using rule 37 (letStatement -> LET varName EQ expression SEMICOLON .)
    DO              reduce using rule 37 (letStatement -> LET varName EQ expression SEMICOLON .)
    RETURN          reduce using rule 37 (letStatement -> LET varName EQ expression SEMICOLON .)
    RCURLY          reduce using rule 37 (letStatement -> LET varName EQ expression SEMICOLON .)


state 185

    (38) letStatement -> LET varName LSQUARE expression RSQUARE . EQ expression SEMICOLON

    EQ              shift and go to state 193


state 186

    (25) commaVarNames -> COMMA varName commaVarNames .

    SEMICOLON       reduce using rule 25 (commaVarNames -> COMMA varName commaVarNames .)


state 187

    (23) varDecs -> VAR type varName commaVarNames SEMICOLON varDecs .

    LET             reduce using rule 23 (varDecs -> VAR type varName commaVarNames SEMICOLON varDecs .)
    IF              reduce using rule 23 (varDecs -> VAR type varName commaVarNames SEMICOLON varDecs .)
    WHILE           reduce using rule 23 (varDecs -> VAR type varName commaVarNames SEMICOLON varDecs .)
    DO              reduce using rule 23 (varDecs -> VAR type varName commaVarNames SEMICOLON varDecs .)
    RETURN          reduce using rule 23 (varDecs -> VAR type varName commaVarNames SEMICOLON varDecs .)
    RCURLY          reduce using rule 23 (varDecs -> VAR type varName commaVarNames SEMICOLON varDecs .)


state 188

    (58) subroutineCall -> varName DOT subroutineName LPAREN expressionList . RPAREN

    RPAREN          shift and go to state 194


state 189

    (57) subroutineCall -> className DOT subroutineName LPAREN expressionList . RPAREN

    RPAREN          shift and go to state 195


state 190

    (61) commaExpressions -> COMMA expression . commaExpressions
    (61) commaExpressions -> . COMMA expression commaExpressions
    (62) commaExpressions -> . empty
    (78) empty -> .

    COMMA           shift and go to state 177
    RPAREN          reduce using rule 78 (empty -> .)

    empty                          shift and go to state 178
    commaExpressions               shift and go to state 196

state 191

    (41) whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements . RCURLY

    RCURLY          shift and go to state 197


state 192

    (39) ifStatement -> IF LPAREN expression RPAREN LCURLY statements . RCURLY
    (40) ifStatement -> IF LPAREN expression RPAREN LCURLY statements . RCURLY ELSE LCURLY statements RCURLY

    RCURLY          shift and go to state 198


state 193

    (38) letStatement -> LET varName LSQUARE expression RSQUARE EQ . expression SEMICOLON
    (45) expression -> . term opTerms
    (48) term -> . INT_CONST
    (49) term -> . LPAREN expression RPAREN
    (50) term -> . unaryOp term
    (51) term -> . subroutineCall
    (52) term -> . varName
    (53) term -> . keywordConstant
    (54) term -> . STRING_CONST
    (55) term -> . varName LSQUARE expression RSQUARE
    (72) unaryOp -> . MINUS
    (73) unaryOp -> . TILDE
    (56) subroutineCall -> . subroutineName LPAREN expressionList RPAREN
    (57) subroutineCall -> . className DOT subroutineName LPAREN expressionList RPAREN
    (58) subroutineCall -> . varName DOT subroutineName LPAREN expressionList RPAREN
    (29) varName -> . IDENTIFIER
    (74) keywordConstant -> . TRUE
    (75) keywordConstant -> . FALSE
    (76) keywordConstant -> . NULL
    (77) keywordConstant -> . THIS
    (28) subroutineName -> . IDENTIFIER
    (27) className -> . IDENTIFIER

    INT_CONST       shift and go to state 118
    LPAREN          shift and go to state 111
    STRING_CONST    shift and go to state 117
    MINUS           shift and go to state 116
    TILDE           shift and go to state 121
    IDENTIFIER      shift and go to state 122
    TRUE            shift and go to state 115
    FALSE           shift and go to state 124
    NULL            shift and go to state 114
    THIS            shift and go to state 126

    term                           shift and go to state 123
    subroutineCall                 shift and go to state 119
    unaryOp                        shift and go to state 125
    varName                        shift and go to state 112
    className                      shift and go to state 106
    keywordConstant                shift and go to state 113
    subroutineName                 shift and go to state 107
    expression                     shift and go to state 199

state 194

    (58) subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .

    PLUS            reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    MINUS           reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    TIMES           reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    DIVIDE          reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    AMP             reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    PIPE            reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    LT              reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    GT              reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    EQ              reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    SEMICOLON       reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    RPAREN          reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    COMMA           reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)
    RSQUARE         reduce using rule 58 (subroutineCall -> varName DOT subroutineName LPAREN expressionList RPAREN .)


state 195

    (57) subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .

    PLUS            reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    MINUS           reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    TIMES           reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    DIVIDE          reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    AMP             reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    PIPE            reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    LT              reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    GT              reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    EQ              reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    SEMICOLON       reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    RPAREN          reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    COMMA           reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)
    RSQUARE         reduce using rule 57 (subroutineCall -> className DOT subroutineName LPAREN expressionList RPAREN .)


state 196

    (61) commaExpressions -> COMMA expression commaExpressions .

    RPAREN          reduce using rule 61 (commaExpressions -> COMMA expression commaExpressions .)


state 197

    (41) whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .

    LET             reduce using rule 41 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)
    IF              reduce using rule 41 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)
    WHILE           reduce using rule 41 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)
    DO              reduce using rule 41 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)
    RETURN          reduce using rule 41 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)
    RCURLY          reduce using rule 41 (whileStatement -> WHILE LPAREN expression RPAREN LCURLY statements RCURLY .)


state 198

    (39) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .
    (40) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY . ELSE LCURLY statements RCURLY

    LET             reduce using rule 39 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    IF              reduce using rule 39 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    WHILE           reduce using rule 39 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    DO              reduce using rule 39 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    RETURN          reduce using rule 39 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    RCURLY          reduce using rule 39 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY .)
    ELSE            shift and go to state 200


state 199

    (38) letStatement -> LET varName LSQUARE expression RSQUARE EQ expression . SEMICOLON

    SEMICOLON       shift and go to state 201


state 200

    (40) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE . LCURLY statements RCURLY

    LCURLY          shift and go to state 202


state 201

    (38) letStatement -> LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON .

    LET             reduce using rule 38 (letStatement -> LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON .)
    IF              reduce using rule 38 (letStatement -> LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON .)
    WHILE           reduce using rule 38 (letStatement -> LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON .)
    DO              reduce using rule 38 (letStatement -> LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON .)
    RETURN          reduce using rule 38 (letStatement -> LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON .)
    RCURLY          reduce using rule 38 (letStatement -> LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON .)


state 202

    (40) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY . statements RCURLY
    (30) statements -> . statement statements
    (31) statements -> . empty
    (32) statement -> . letStatement
    (33) statement -> . ifStatement
    (34) statement -> . whileStatement
    (35) statement -> . doStatement
    (36) statement -> . returnStatement
    (78) empty -> .
    (37) letStatement -> . LET varName EQ expression SEMICOLON
    (38) letStatement -> . LET varName LSQUARE expression RSQUARE EQ expression SEMICOLON
    (39) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY
    (40) ifStatement -> . IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY
    (41) whileStatement -> . WHILE LPAREN expression RPAREN LCURLY statements RCURLY
    (42) doStatement -> . DO subroutineCall SEMICOLON
    (43) returnStatement -> . RETURN SEMICOLON
    (44) returnStatement -> . RETURN expression SEMICOLON

    RCURLY          reduce using rule 78 (empty -> .)
    LET             shift and go to state 101
    IF              shift and go to state 99
    WHILE           shift and go to state 91
    DO              shift and go to state 89
    RETURN          shift and go to state 92

    statements                     shift and go to state 203
    doStatement                    shift and go to state 93
    whileStatement                 shift and go to state 97
    letStatement                   shift and go to state 100
    statement                      shift and go to state 94
    returnStatement                shift and go to state 98
    empty                          shift and go to state 96
    ifStatement                    shift and go to state 95

state 203

    (40) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements . RCURLY

    RCURLY          shift and go to state 204


state 204

    (40) ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .

    LET             reduce using rule 40 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    IF              reduce using rule 40 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    WHILE           reduce using rule 40 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    DO              reduce using rule 40 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    RETURN          reduce using rule 40 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)
    RCURLY          reduce using rule 40 (ifStatement -> IF LPAREN expression RPAREN LCURLY statements RCURLY ELSE LCURLY statements RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 108 resolved using rule (className -> IDENTIFIER)
WARNING: rejected rule (varName -> IDENTIFIER) in state 108
WARNING: reduce/reduce conflict in state 122 resolved using rule (className -> IDENTIFIER)
WARNING: rejected rule (varName -> IDENTIFIER) in state 122
